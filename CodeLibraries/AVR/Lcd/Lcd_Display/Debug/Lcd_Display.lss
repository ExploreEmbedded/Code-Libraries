
Lcd_Display.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000618  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  00000618  000006ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000005  00800080  00800080  000006cc  2**0
                  ALLOC
  3 .debug_aranges 00000060  00000000  00000000  000006cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000015c  00000000  00000000  0000072c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000009cf  00000000  00000000  00000888  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000038a  00000000  00000000  00001257  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000929  00000000  00000000  000015e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000120  00000000  00000000  00001f0c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000469  00000000  00000000  0000202c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000530  00000000  00000000  00002495  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000090  00000000  00000000  000029c5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 e1       	ldi	r30, 0x18	; 24
  68:	f6 e0       	ldi	r31, 0x06	; 6
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a0 38       	cpi	r26, 0x80	; 128
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a0 e8       	ldi	r26, 0x80	; 128
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a5 38       	cpi	r26, 0x85	; 133
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 d7 02 	call	0x5ae	; 0x5ae <main>
  8a:	0c 94 0a 03 	jmp	0x614	; 0x614 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DELAY_sec>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  92:	44 e1       	ldi	r20, 0x14	; 20
  94:	51 e0       	ldi	r21, 0x01	; 1
  96:	09 c0       	rjmp	.+18     	; 0xaa <DELAY_sec+0x18>
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  98:	20 e1       	ldi	r18, 0x10	; 16
  9a:	37 e2       	ldi	r19, 0x27	; 39
  9c:	fa 01       	movw	r30, r20
  9e:	31 97       	sbiw	r30, 0x01	; 1
  a0:	f1 f7       	brne	.-4      	; 0x9e <DELAY_sec+0xc>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  a2:	21 50       	subi	r18, 0x01	; 1
  a4:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  a6:	d1 f7       	brne	.-12     	; 0x9c <DELAY_sec+0xa>
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
  a8:	01 97       	sbiw	r24, 0x01	; 1
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  aa:	00 97       	sbiw	r24, 0x00	; 0
  ac:	a9 f7       	brne	.-22     	; 0x98 <DELAY_sec+0x6>
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
		}
  }
  ae:	08 95       	ret

000000b0 <lcd_BusyCheck>:
static void lcd_BusyCheck()
{
	uint8_t busyflag;
#ifdef LCD_RW       //Perform Busy check if LCD_RW pin is used

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
  b0:	a7 98       	cbi	0x14, 7	; 20
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
  b2:	95 98       	cbi	0x12, 5	; 18
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
  b4:	96 9a       	sbi	0x12, 6	; 18
		M_LcdSetBit(LCD_EN); 
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
  b6:	30 91 84 00 	lds	r19, 0x0084
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
  ba:	94 e2       	ldi	r25, 0x24	; 36
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
	do
	{

		M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
  bc:	97 98       	cbi	0x12, 7	; 18
  be:	89 2f       	mov	r24, r25
  c0:	8a 95       	dec	r24
  c2:	f1 f7       	brne	.-4      	; 0xc0 <lcd_BusyCheck+0x10>
		DELAY_us(10);	
		M_LcdSetBit(LCD_EN); 
  c4:	97 9a       	sbi	0x12, 7	; 18
  c6:	89 2f       	mov	r24, r25
  c8:	8a 95       	dec	r24
  ca:	f1 f7       	brne	.-4      	; 0xc8 <lcd_BusyCheck+0x18>
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
  cc:	23 b3       	in	r18, 0x13	; 19


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
  ce:	34 30       	cpi	r19, 0x04	; 4
  d0:	41 f4       	brne	.+16     	; 0xe2 <lcd_BusyCheck+0x32>
		{
			/* Perform extra dummy read for 4-bit */ 	   	
			M_LcdClearBit(LCD_EN);
  d2:	97 98       	cbi	0x12, 7	; 18
  d4:	89 2f       	mov	r24, r25
  d6:	8a 95       	dec	r24
  d8:	f1 f7       	brne	.-4      	; 0xd6 <lcd_BusyCheck+0x26>
			DELAY_us(10);
			M_LcdSetBit(LCD_EN); 
  da:	97 9a       	sbi	0x12, 7	; 18
  dc:	89 2f       	mov	r24, r25
  de:	8a 95       	dec	r24
  e0:	f1 f7       	brne	.-4      	; 0xde <lcd_BusyCheck+0x2e>
			DELAY_us(10);
		}	
	}while(busyflag);
  e2:	27 fd       	sbrc	r18, 7
  e4:	eb cf       	rjmp	.-42     	; 0xbc <lcd_BusyCheck+0xc>

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
  e6:	a7 9a       	sbi	0x14, 7	; 20
#else
	/* Busy flag cannot be read as LCD_RW is not available hence Extra delay of 1ms is added 
	  to ensure the LCD completes previous operation and ready to receive new commands/data */
	DELAY_ms(1);  
#endif
}
  e8:	08 95       	ret

000000ea <lcd_SendNibble>:

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 *************************************************************************************************/
static void lcd_SendNibble(uint8_t var)
{
	util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
  ea:	98 2f       	mov	r25, r24
  ec:	84 ff       	sbrs	r24, 4
  ee:	02 c0       	rjmp	.+4      	; 0xf4 <lcd_SendNibble+0xa>
  f0:	ac 9a       	sbi	0x15, 4	; 21
  f2:	01 c0       	rjmp	.+2      	; 0xf6 <lcd_SendNibble+0xc>
  f4:	ac 98       	cbi	0x15, 4	; 21
  f6:	25 b3       	in	r18, 0x15	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
  f8:	95 ff       	sbrs	r25, 5
  fa:	02 c0       	rjmp	.+4      	; 0x100 <lcd_SendNibble+0x16>
  fc:	ad 9a       	sbi	0x15, 5	; 21
  fe:	01 c0       	rjmp	.+2      	; 0x102 <lcd_SendNibble+0x18>
 100:	ad 98       	cbi	0x15, 5	; 21
 102:	25 b3       	in	r18, 0x15	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
 104:	96 ff       	sbrs	r25, 6
 106:	02 c0       	rjmp	.+4      	; 0x10c <lcd_SendNibble+0x22>
 108:	ae 9a       	sbi	0x15, 6	; 21
 10a:	01 c0       	rjmp	.+2      	; 0x10e <lcd_SendNibble+0x24>
 10c:	ae 98       	cbi	0x15, 6	; 21
 10e:	95 b3       	in	r25, 0x15	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
 110:	87 ff       	sbrs	r24, 7
 112:	02 c0       	rjmp	.+4      	; 0x118 <lcd_SendNibble+0x2e>
 114:	af 9a       	sbi	0x15, 7	; 21
 116:	01 c0       	rjmp	.+2      	; 0x11a <lcd_SendNibble+0x30>
 118:	af 98       	cbi	0x15, 7	; 21
 11a:	85 b3       	in	r24, 0x15	; 21
 11c:	08 95       	ret

0000011e <lcd_SendCmdSignals>:

 * description : This functions generates the signals for sending the var_lcdCmd_u8 to LCD
 *************************************************************************************************/
static void lcd_SendCmdSignals()
{
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 11e:	95 98       	cbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
 120:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
 122:	97 9a       	sbi	0x12, 7	; 18
 124:	84 e2       	ldi	r24, 0x24	; 36
 126:	8a 95       	dec	r24
 128:	f1 f7       	brne	.-4      	; 0x126 <lcd_SendCmdSignals+0x8>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 12a:	97 98       	cbi	0x12, 7	; 18
}
 12c:	08 95       	ret

0000012e <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.				
				The behaviour is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
{
 12e:	1f 93       	push	r17
 130:	18 2f       	mov	r17, r24
	lcd_BusyCheck();
 132:	0e 94 58 00 	call	0xb0	; 0xb0 <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 136:	80 91 84 00 	lds	r24, 0x0084
 13a:	88 30       	cpi	r24, 0x08	; 8
 13c:	11 f4       	brne	.+4      	; 0x142 <LCD_CmdWrite+0x14>
	{

		M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
 13e:	15 bb       	out	0x15, r17	; 21
 140:	0c c0       	rjmp	.+24     	; 0x15a <LCD_CmdWrite+0x2c>
		lcd_SendCmdSignals();  // Signals for command write operation
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 142:	84 30       	cpi	r24, 0x04	; 4
 144:	61 f4       	brne	.+24     	; 0x15e <LCD_CmdWrite+0x30>
	{
		lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
 146:	81 2f       	mov	r24, r17
 148:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
		lcd_SendCmdSignals(); // Signals for command write operation
 14c:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>

		lcd_SendNibble(var_lcdCmd_u8 << 4);
 150:	81 2f       	mov	r24, r17
 152:	82 95       	swap	r24
 154:	80 7f       	andi	r24, 0xF0	; 240
 156:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
		lcd_SendCmdSignals();
 15a:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>
	}
}
 15e:	1f 91       	pop	r17
 160:	08 95       	ret

00000162 <LCD_GoToNextLine>:
 ***************************************************************************************************/
void  LCD_GoToNextLine()
{
	/*Increment the current line number.
	  In case it exceeds the limit, rool it back to first line */
	VAR_LcdTrackLineNum_U8++;
 162:	80 91 81 00 	lds	r24, 0x0081
 166:	8f 5f       	subi	r24, 0xFF	; 255
 168:	80 93 81 00 	sts	0x0081, r24
	VAR_LcdTrackCursorPos_U8 = 0x00;
 16c:	10 92 80 00 	sts	0x0080, r1
	if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 170:	90 91 82 00 	lds	r25, 0x0082
 174:	98 17       	cp	r25, r24
 176:	18 f4       	brcc	.+6      	; 0x17e <LCD_GoToNextLine+0x1c>
		VAR_LcdTrackLineNum_U8 = 0x01;
 178:	81 e0       	ldi	r24, 0x01	; 1
 17a:	80 93 81 00 	sts	0x0081, r24
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
 17e:	e0 91 81 00 	lds	r30, 0x0081
 182:	f0 e0       	ldi	r31, 0x00	; 0
 184:	e0 5a       	subi	r30, 0xA0	; 160
 186:	ff 4f       	sbci	r31, 0xFF	; 255
 188:	80 81       	ld	r24, Z
 18a:	0e 94 97 00 	call	0x12e	; 0x12e <LCD_CmdWrite>
}
 18e:	08 95       	ret

00000190 <LCD_GoToLine>:
           mENUM_LcdLineTwo,
           mENUM_LcdLineThree,
           mENUM_LcdLineFour,
 ***************************************************************************************************/
void LCD_GoToLine(uint8_t var_lineNumber_u8)
{
 190:	e8 2f       	mov	r30, r24
	if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
 192:	80 91 82 00 	lds	r24, 0x0082
 196:	8e 17       	cp	r24, r30
 198:	50 f0       	brcs	.+20     	; 0x1ae <LCD_GoToLine+0x1e>
	{
		/* If the line number is within range then
	       Move the Cursor to beginning of the specified line */
		VAR_LcdTrackCursorPos_U8 = 0x00;
 19a:	10 92 80 00 	sts	0x0080, r1
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 19e:	e0 93 81 00 	sts	0x0081, r30
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
 1a2:	f0 e0       	ldi	r31, 0x00	; 0
 1a4:	e0 5a       	subi	r30, 0xA0	; 160
 1a6:	ff 4f       	sbci	r31, 0xFF	; 255
 1a8:	80 81       	ld	r24, Z
 1aa:	0e 94 97 00 	call	0x12e	; 0x12e <LCD_CmdWrite>
 1ae:	08 95       	ret

000001b0 <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ***************************************************************************************************/
void LCD_Clear()
{
	LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
 1b0:	81 e0       	ldi	r24, 0x01	; 1
 1b2:	0e 94 97 00 	call	0x12e	; 0x12e <LCD_CmdWrite>
	LCD_GoToLine(mENUM_LcdLineOne);
 1b6:	81 e0       	ldi	r24, 0x01	; 1
 1b8:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_GoToLine>
}
 1bc:	08 95       	ret

000001be <LCD_Init>:

 * description  :This function is used to initialize the lcd.
                 *It initializes the LCD for selected mode(4/8-bit) and Type(16x2/16x1 etc)
**************************************************************************************************/
void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
{
 1be:	0f 93       	push	r16
 1c0:	1f 93       	push	r17
 1c2:	58 2f       	mov	r21, r24


	M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
 1c4:	8f ef       	ldi	r24, 0xFF	; 255
 1c6:	84 bb       	out	0x14, r24	; 20
	M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
 1c8:	81 bb       	out	0x11, r24	; 17
	STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
 1ca:	50 93 84 00 	sts	0x0084, r21
	STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
 1ce:	40 93 83 00 	sts	0x0083, r20
	STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
 1d2:	60 93 82 00 	sts	0x0082, r22
	if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
 1d6:	63 30       	cpi	r22, 0x03	; 3
 1d8:	40 f0       	brcs	.+16     	; 0x1ea <LCD_Init+0x2c>
	{
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
 1da:	84 2f       	mov	r24, r20
 1dc:	8f 70       	andi	r24, 0x0F	; 15
 1de:	80 57       	subi	r24, 0x70	; 112
 1e0:	80 93 63 00 	sts	0x0063, r24
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
 1e4:	80 5c       	subi	r24, 0xC0	; 192
 1e6:	80 93 64 00 	sts	0x0064, r24
 1ea:	88 ee       	ldi	r24, 0xE8	; 232
 1ec:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1ee:	24 e1       	ldi	r18, 0x14	; 20
 1f0:	31 e0       	ldi	r19, 0x01	; 1
 1f2:	f9 01       	movw	r30, r18
 1f4:	31 97       	sbiw	r30, 0x01	; 1
 1f6:	f1 f7       	brne	.-4      	; 0x1f4 <LCD_Init+0x36>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1f8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1fa:	d9 f7       	brne	.-10     	; 0x1f2 <LCD_Init+0x34>
	}

	DELAY_ms(100);

	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 1fc:	58 30       	cpi	r21, 0x08	; 8
 1fe:	11 f4       	brne	.+4      	; 0x204 <LCD_Init+0x46>
	{
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 200:	88 e3       	ldi	r24, 0x38	; 56
 202:	2b c0       	rjmp	.+86     	; 0x25a <LCD_Init+0x9c>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 204:	54 30       	cpi	r21, 0x04	; 4
 206:	59 f5       	brne	.+86     	; 0x25e <LCD_Init+0xa0>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset()
{
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendNibble(0x30);
 208:	80 e3       	ldi	r24, 0x30	; 48
 20a:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
	lcd_SendCmdSignals();
 20e:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>
 212:	88 ee       	ldi	r24, 0xE8	; 232
 214:	93 e0       	ldi	r25, 0x03	; 3
 216:	24 e1       	ldi	r18, 0x14	; 20
 218:	31 e0       	ldi	r19, 0x01	; 1
 21a:	f9 01       	movw	r30, r18
 21c:	31 97       	sbiw	r30, 0x01	; 1
 21e:	f1 f7       	brne	.-4      	; 0x21c <LCD_Init+0x5e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 220:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 222:	d9 f7       	brne	.-10     	; 0x21a <LCD_Init+0x5c>
	DELAY_ms(100);
	lcd_SendNibble(0x30);
 224:	80 e3       	ldi	r24, 0x30	; 48
 226:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
	lcd_SendCmdSignals();
 22a:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>
 22e:	08 e2       	ldi	r16, 0x28	; 40
 230:	12 e0       	ldi	r17, 0x02	; 2
 232:	c8 01       	movw	r24, r16
 234:	01 97       	sbiw	r24, 0x01	; 1
 236:	f1 f7       	brne	.-4      	; 0x234 <LCD_Init+0x76>
	DELAY_us(200);
	lcd_SendNibble(0x30);
 238:	80 e3       	ldi	r24, 0x30	; 48
 23a:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
	lcd_SendCmdSignals();
 23e:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>
 242:	c8 01       	movw	r24, r16
 244:	01 97       	sbiw	r24, 0x01	; 1
 246:	f1 f7       	brne	.-4      	; 0x244 <LCD_Init+0x86>
	DELAY_us(200);
	lcd_SendNibble(0x20);
 248:	80 e2       	ldi	r24, 0x20	; 32
 24a:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
	lcd_SendCmdSignals();
 24e:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>
 252:	c8 01       	movw	r24, r16
 254:	01 97       	sbiw	r24, 0x01	; 1
 256:	f1 f7       	brne	.-4      	; 0x254 <LCD_Init+0x96>
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
	{
		lcd_Reset();
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 258:	88 e2       	ldi	r24, 0x28	; 40
 25a:	0e 94 97 00 	call	0x12e	; 0x12e <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);	 // Display ON cursor ON
 25e:	8e e0       	ldi	r24, 0x0E	; 14
 260:	0e 94 97 00 	call	0x12e	; 0x12e <LCD_CmdWrite>
	LCD_Clear();	                         // Clear the LCD and go to First line First Position
 264:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <LCD_Clear>
}
 268:	1f 91       	pop	r17
 26a:	0f 91       	pop	r16
 26c:	08 95       	ret

0000026e <lcd_SendDataSignals>:

 * description : This functions generates the signals for sending the Data to LCD
 *************************************************************************************************/
static void lcd_SendDataSignals()
{
	M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
 26e:	95 9a       	sbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
 270:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
 272:	97 9a       	sbi	0x12, 7	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 274:	84 e2       	ldi	r24, 0x24	; 36
 276:	8a 95       	dec	r24
 278:	f1 f7       	brne	.-4      	; 0x276 <lcd_SendDataSignals+0x8>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 27a:	97 98       	cbi	0x12, 7	; 18
}
 27c:	08 95       	ret

0000027e <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
void LCD_DisplayChar(char var_lcdData_u8)
{
 27e:	1f 93       	push	r17
 280:	18 2f       	mov	r17, r24
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
 282:	90 91 80 00 	lds	r25, 0x0080
 286:	80 91 83 00 	lds	r24, 0x0083
 28a:	98 17       	cp	r25, r24
 28c:	10 f4       	brcc	.+4      	; 0x292 <LCD_DisplayChar+0x14>
 28e:	1a 30       	cpi	r17, 0x0A	; 10
 290:	21 f4       	brne	.+8      	; 0x29a <LCD_DisplayChar+0x1c>
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 292:	0e 94 b1 00 	call	0x162	; 0x162 <LCD_GoToNextLine>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 296:	1a 30       	cpi	r17, 0x0A	; 10
 298:	d9 f0       	breq	.+54     	; 0x2d0 <LCD_DisplayChar+0x52>

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void lcd_DataWrite( uint8_t dat)
{
	lcd_BusyCheck();
 29a:	0e 94 58 00 	call	0xb0	; 0xb0 <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 29e:	80 91 84 00 	lds	r24, 0x0084
 2a2:	88 30       	cpi	r24, 0x08	; 8
 2a4:	11 f4       	brne	.+4      	; 0x2aa <LCD_DisplayChar+0x2c>
	{
		M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
 2a6:	15 bb       	out	0x15, r17	; 21
 2a8:	0c c0       	rjmp	.+24     	; 0x2c2 <LCD_DisplayChar+0x44>
		lcd_SendDataSignals();  // Signals for data write operation
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 2aa:	84 30       	cpi	r24, 0x04	; 4
 2ac:	61 f4       	brne	.+24     	; 0x2c6 <LCD_DisplayChar+0x48>
	{
		lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
 2ae:	81 2f       	mov	r24, r17
 2b0:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
		lcd_SendDataSignals();  // Signals for data write operation
 2b4:	0e 94 37 01 	call	0x26e	; 0x26e <lcd_SendDataSignals>

		lcd_SendNibble(dat << 4);
 2b8:	81 2f       	mov	r24, r17
 2ba:	82 95       	swap	r24
 2bc:	80 7f       	andi	r24, 0xF0	; 240
 2be:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
		lcd_SendDataSignals();
 2c2:	0e 94 37 01 	call	0x26e	; 0x26e <lcd_SendDataSignals>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
 2c6:	80 91 80 00 	lds	r24, 0x0080
 2ca:	8f 5f       	subi	r24, 0xFF	; 255
 2cc:	80 93 80 00 	sts	0x0080, r24
	}
}
 2d0:	1f 91       	pop	r17
 2d2:	08 95       	ret

000002d4 <LCD_DisplayDecimalNumber>:
				2.(12345,6) then 6-digits ie. 012345 will be displayed
				3.(12345,C_DisplayDefaultDigits_U8) then 12345 will be displayed.
 ***************************************************************************************************/
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
 2d4:	6f 92       	push	r6
 2d6:	7f 92       	push	r7
 2d8:	9f 92       	push	r9
 2da:	af 92       	push	r10
 2dc:	bf 92       	push	r11
 2de:	cf 92       	push	r12
 2e0:	df 92       	push	r13
 2e2:	ef 92       	push	r14
 2e4:	ff 92       	push	r15
 2e6:	0f 93       	push	r16
 2e8:	df 93       	push	r29
 2ea:	cf 93       	push	r28
 2ec:	cd b7       	in	r28, 0x3d	; 61
 2ee:	de b7       	in	r29, 0x3e	; 62
 2f0:	2a 97       	sbiw	r28, 0x0a	; 10
 2f2:	0f b6       	in	r0, 0x3f	; 63
 2f4:	f8 94       	cli
 2f6:	de bf       	out	0x3e, r29	; 62
 2f8:	0f be       	out	0x3f, r0	; 63
 2fa:	cd bf       	out	0x3d, r28	; 61
 2fc:	6b 01       	movw	r12, r22
 2fe:	7c 01       	movw	r14, r24
 300:	94 2e       	mov	r9, r20
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
 302:	61 15       	cp	r22, r1
 304:	71 05       	cpc	r23, r1
 306:	81 05       	cpc	r24, r1
 308:	91 05       	cpc	r25, r1
 30a:	31 f0       	breq	.+12     	; 0x318 <LCD_DisplayDecimalNumber+0x44>
 30c:	00 e0       	ldi	r16, 0x00	; 0
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
 30e:	3e 01       	movw	r6, r28
 310:	08 94       	sec
 312:	61 1c       	adc	r6, r1
 314:	71 1c       	adc	r7, r1
 316:	32 c0       	rjmp	.+100    	; 0x37c <LCD_DisplayDecimalNumber+0xa8>
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
 318:	fe 01       	movw	r30, r28
 31a:	31 96       	adiw	r30, 0x01	; 1
 31c:	00 e0       	ldi	r16, 0x00	; 0
 31e:	02 c0       	rjmp	.+4      	; 0x324 <LCD_DisplayDecimalNumber+0x50>
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
 320:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 322:	0f 5f       	subi	r16, 0xFF	; 255
 324:	09 15       	cp	r16, r9
 326:	a8 f5       	brcc	.+106    	; 0x392 <LCD_DisplayDecimalNumber+0xbe>
 328:	0a 30       	cpi	r16, 0x0A	; 10
 32a:	d1 f7       	brne	.-12     	; 0x320 <LCD_DisplayDecimalNumber+0x4c>
 32c:	32 c0       	rjmp	.+100    	; 0x392 <LCD_DisplayDecimalNumber+0xbe>
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_DecNumber_u32!=0)
 32e:	c1 14       	cp	r12, r1
 330:	d1 04       	cpc	r13, r1
 332:	e1 04       	cpc	r14, r1
 334:	f1 04       	cpc	r15, r1
 336:	d1 f0       	breq	.+52     	; 0x36c <LCD_DisplayDecimalNumber+0x98>
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 338:	53 01       	movw	r10, r6
 33a:	a0 0e       	add	r10, r16
 33c:	b1 1c       	adc	r11, r1
 33e:	c7 01       	movw	r24, r14
 340:	b6 01       	movw	r22, r12
 342:	2a e0       	ldi	r18, 0x0A	; 10
 344:	30 e0       	ldi	r19, 0x00	; 0
 346:	40 e0       	ldi	r20, 0x00	; 0
 348:	50 e0       	ldi	r21, 0x00	; 0
 34a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <__udivmodsi4>
 34e:	f5 01       	movw	r30, r10
 350:	60 83       	st	Z, r22
				var_DecNumber_u32=var_DecNumber_u32/10;
 352:	c7 01       	movw	r24, r14
 354:	b6 01       	movw	r22, r12
 356:	2a e0       	ldi	r18, 0x0A	; 10
 358:	30 e0       	ldi	r19, 0x00	; 0
 35a:	40 e0       	ldi	r20, 0x00	; 0
 35c:	50 e0       	ldi	r21, 0x00	; 0
 35e:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <__udivmodsi4>
 362:	c9 01       	movw	r24, r18
 364:	da 01       	movw	r26, r20
 366:	6c 01       	movw	r12, r24
 368:	7d 01       	movw	r14, r26
 36a:	07 c0       	rjmp	.+14     	; 0x37a <LCD_DisplayDecimalNumber+0xa6>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 36c:	fa e0       	ldi	r31, 0x0A	; 10
 36e:	f9 15       	cp	r31, r9
 370:	80 f0       	brcs	.+32     	; 0x392 <LCD_DisplayDecimalNumber+0xbe>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
 372:	f3 01       	movw	r30, r6
 374:	e0 0f       	add	r30, r16
 376:	f1 1d       	adc	r31, r1
 378:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 37a:	0f 5f       	subi	r16, 0xFF	; 255
 37c:	09 15       	cp	r16, r9
 37e:	b8 f2       	brcs	.-82     	; 0x32e <LCD_DisplayDecimalNumber+0x5a>
 380:	08 c0       	rjmp	.+16     	; 0x392 <LCD_DisplayDecimalNumber+0xbe>


	while(i)
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
 382:	fe 01       	movw	r30, r28
 384:	e0 0f       	add	r30, r16
 386:	f1 1d       	adc	r31, r1
 388:	80 81       	ld	r24, Z
 38a:	80 5d       	subi	r24, 0xD0	; 208
 38c:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
		i--;
 390:	01 50       	subi	r16, 0x01	; 1
			}
		}
	}


	while(i)
 392:	00 23       	and	r16, r16
 394:	b1 f7       	brne	.-20     	; 0x382 <LCD_DisplayDecimalNumber+0xae>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
		i--;
	}
}
 396:	2a 96       	adiw	r28, 0x0a	; 10
 398:	0f b6       	in	r0, 0x3f	; 63
 39a:	f8 94       	cli
 39c:	de bf       	out	0x3e, r29	; 62
 39e:	0f be       	out	0x3f, r0	; 63
 3a0:	cd bf       	out	0x3d, r28	; 61
 3a2:	cf 91       	pop	r28
 3a4:	df 91       	pop	r29
 3a6:	0f 91       	pop	r16
 3a8:	ff 90       	pop	r15
 3aa:	ef 90       	pop	r14
 3ac:	df 90       	pop	r13
 3ae:	cf 90       	pop	r12
 3b0:	bf 90       	pop	r11
 3b2:	af 90       	pop	r10
 3b4:	9f 90       	pop	r9
 3b6:	7f 90       	pop	r7
 3b8:	6f 90       	pop	r6
 3ba:	08 95       	ret

000003bc <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
 3bc:	cf 93       	push	r28
 3be:	df 93       	push	r29
 3c0:	ec 01       	movw	r28, r24
 3c2:	03 c0       	rjmp	.+6      	; 0x3ca <LCD_DisplayString+0xe>
	while((*ptr_stringPointer_u8)!=0)
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
 3c4:	21 96       	adiw	r28, 0x01	; 1
 3c6:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
	while((*ptr_stringPointer_u8)!=0)
 3ca:	88 81       	ld	r24, Y
 3cc:	88 23       	and	r24, r24
 3ce:	d1 f7       	brne	.-12     	; 0x3c4 <LCD_DisplayString+0x8>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
 3d0:	df 91       	pop	r29
 3d2:	cf 91       	pop	r28
 3d4:	08 95       	ret

000003d6 <LCD_Printf>:
	     %12b: will display the 12-LSB of the number
		 %d: Will display the exact digits of the number
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
 3d6:	8f 92       	push	r8
 3d8:	9f 92       	push	r9
 3da:	af 92       	push	r10
 3dc:	bf 92       	push	r11
 3de:	cf 92       	push	r12
 3e0:	df 92       	push	r13
 3e2:	ef 92       	push	r14
 3e4:	ff 92       	push	r15
 3e6:	0f 93       	push	r16
 3e8:	1f 93       	push	r17
 3ea:	df 93       	push	r29
 3ec:	cf 93       	push	r28
 3ee:	cd b7       	in	r28, 0x3d	; 61
 3f0:	de b7       	in	r29, 0x3e	; 62
 3f2:	31 e1       	ldi	r19, 0x11	; 17
 3f4:	e3 2e       	mov	r14, r19
 3f6:	f1 2c       	mov	r15, r1
 3f8:	ec 0e       	add	r14, r28
 3fa:	fd 1e       	adc	r15, r29
 3fc:	8f 85       	ldd	r24, Y+15	; 0x0f
 3fe:	98 89       	ldd	r25, Y+16	; 0x10
 400:	9c 01       	movw	r18, r24
 402:	59 01       	movw	r10, r18
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 404:	2a e0       	ldi	r18, 0x0A	; 10
 406:	c2 2e       	mov	r12, r18
 408:	c0 c0       	rjmp	.+384    	; 0x58a <__stack+0x12b>
	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
	{

		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
 40a:	85 32       	cpi	r24, 0x25	; 37
 40c:	09 f0       	breq	.+2      	; 0x410 <LCD_Printf+0x3a>
 40e:	b8 c0       	rjmp	.+368    	; 0x580 <__stack+0x121>
		{
		    ptr++;
 410:	08 94       	sec
 412:	a1 1c       	adc	r10, r1
 414:	b1 1c       	adc	r11, r1
		    ch = *ptr;
 416:	f5 01       	movw	r30, r10
 418:	90 81       	ld	r25, Z
		   if((ch>=0x30) && (ch<=0x39))
 41a:	89 2f       	mov	r24, r25
 41c:	80 53       	subi	r24, 0x30	; 48
 41e:	8a 30       	cpi	r24, 0x0A	; 10
 420:	18 f0       	brcs	.+6      	; 0x428 <LCD_Printf+0x52>
 422:	dd 24       	eor	r13, r13
 424:	da 94       	dec	r13
 426:	0f c0       	rjmp	.+30     	; 0x446 <LCD_Printf+0x70>
 428:	dd 24       	eor	r13, r13
 42a:	09 c0       	rjmp	.+18     	; 0x43e <LCD_Printf+0x68>
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 42c:	dc 9c       	mul	r13, r12
 42e:	d0 2c       	mov	r13, r0
 430:	11 24       	eor	r1, r1
 432:	d8 0e       	add	r13, r24
				   ptr++;
 434:	08 94       	sec
 436:	a1 1c       	adc	r10, r1
 438:	b1 1c       	adc	r11, r1
				   ch = *ptr;
 43a:	f5 01       	movw	r30, r10
 43c:	90 81       	ld	r25, Z
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
 43e:	89 2f       	mov	r24, r25
 440:	80 53       	subi	r24, 0x30	; 48
 442:	8a 30       	cpi	r24, 0x0A	; 10
 444:	98 f3       	brcs	.-26     	; 0x42c <LCD_Printf+0x56>
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
 446:	98 35       	cpi	r25, 0x58	; 88
 448:	09 f4       	brne	.+2      	; 0x44c <LCD_Printf+0x76>
 44a:	85 c0       	rjmp	.+266    	; 0x556 <__stack+0xf7>
 44c:	99 35       	cpi	r25, 0x59	; 89
 44e:	c0 f4       	brcc	.+48     	; 0x480 <__stack+0x21>
 450:	94 34       	cpi	r25, 0x44	; 68
 452:	09 f4       	brne	.+2      	; 0x456 <LCD_Printf+0x80>
 454:	4a c0       	rjmp	.+148    	; 0x4ea <__stack+0x8b>
 456:	95 34       	cpi	r25, 0x45	; 69
 458:	48 f4       	brcc	.+18     	; 0x46c <__stack+0xd>
 45a:	92 34       	cpi	r25, 0x42	; 66
 45c:	09 f4       	brne	.+2      	; 0x460 <__stack+0x1>
 45e:	7b c0       	rjmp	.+246    	; 0x556 <__stack+0xf7>
 460:	93 34       	cpi	r25, 0x43	; 67
 462:	28 f5       	brcc	.+74     	; 0x4ae <__stack+0x4f>
 464:	95 32       	cpi	r25, 0x25	; 37
 466:	09 f0       	breq	.+2      	; 0x46a <__stack+0xb>
 468:	8d c0       	rjmp	.+282    	; 0x584 <__stack+0x125>
 46a:	89 c0       	rjmp	.+274    	; 0x57e <__stack+0x11f>
 46c:	93 35       	cpi	r25, 0x53	; 83
 46e:	09 f4       	brne	.+2      	; 0x472 <__stack+0x13>
 470:	7c c0       	rjmp	.+248    	; 0x56a <__stack+0x10b>
 472:	95 35       	cpi	r25, 0x55	; 85
 474:	09 f4       	brne	.+2      	; 0x478 <__stack+0x19>
 476:	60 c0       	rjmp	.+192    	; 0x538 <__stack+0xd9>
 478:	96 34       	cpi	r25, 0x46	; 70
 47a:	09 f0       	breq	.+2      	; 0x47e <__stack+0x1f>
 47c:	83 c0       	rjmp	.+262    	; 0x584 <__stack+0x125>
 47e:	70 c0       	rjmp	.+224    	; 0x560 <__stack+0x101>
 480:	96 36       	cpi	r25, 0x66	; 102
 482:	09 f4       	brne	.+2      	; 0x486 <__stack+0x27>
 484:	6d c0       	rjmp	.+218    	; 0x560 <__stack+0x101>
 486:	97 36       	cpi	r25, 0x67	; 103
 488:	40 f4       	brcc	.+16     	; 0x49a <__stack+0x3b>
 48a:	93 36       	cpi	r25, 0x63	; 99
 48c:	81 f0       	breq	.+32     	; 0x4ae <__stack+0x4f>
 48e:	94 36       	cpi	r25, 0x64	; 100
 490:	b1 f0       	breq	.+44     	; 0x4be <__stack+0x5f>
 492:	92 36       	cpi	r25, 0x62	; 98
 494:	09 f0       	breq	.+2      	; 0x498 <__stack+0x39>
 496:	76 c0       	rjmp	.+236    	; 0x584 <__stack+0x125>
 498:	5b c0       	rjmp	.+182    	; 0x550 <__stack+0xf1>
 49a:	95 37       	cpi	r25, 0x75	; 117
 49c:	09 f4       	brne	.+2      	; 0x4a0 <__stack+0x41>
 49e:	43 c0       	rjmp	.+134    	; 0x526 <__stack+0xc7>
 4a0:	98 37       	cpi	r25, 0x78	; 120
 4a2:	09 f4       	brne	.+2      	; 0x4a6 <__stack+0x47>
 4a4:	55 c0       	rjmp	.+170    	; 0x550 <__stack+0xf1>
 4a6:	93 37       	cpi	r25, 0x73	; 115
 4a8:	09 f0       	breq	.+2      	; 0x4ac <__stack+0x4d>
 4aa:	6c c0       	rjmp	.+216    	; 0x584 <__stack+0x125>
 4ac:	5e c0       	rjmp	.+188    	; 0x56a <__stack+0x10b>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 4ae:	87 01       	movw	r16, r14
 4b0:	0e 5f       	subi	r16, 0xFE	; 254
 4b2:	1f 4f       	sbci	r17, 0xFF	; 255
				LCD_DisplayChar(ch);
 4b4:	f7 01       	movw	r30, r14
 4b6:	80 81       	ld	r24, Z
 4b8:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
 4bc:	5e c0       	rjmp	.+188    	; 0x57a <__stack+0x11b>
				break;

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 4be:	92 e0       	ldi	r25, 0x02	; 2
 4c0:	89 2e       	mov	r8, r25
 4c2:	91 2c       	mov	r9, r1
 4c4:	8e 0c       	add	r8, r14
 4c6:	9f 1c       	adc	r9, r15
 4c8:	f7 01       	movw	r30, r14
 4ca:	00 81       	ld	r16, Z
 4cc:	11 81       	ldd	r17, Z+1	; 0x01
#if (Enable_LCD_DisplayDecimalNumber == 1)
				if(var_num_s16<0)
 4ce:	17 ff       	sbrs	r17, 7
 4d0:	06 c0       	rjmp	.+12     	; 0x4de <__stack+0x7f>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   var_num_s16 = -var_num_s16;
 4d2:	10 95       	com	r17
 4d4:	01 95       	neg	r16
 4d6:	1f 4f       	sbci	r17, 0xFF	; 255
				   LCD_DisplayChar('-');
 4d8:	8d e2       	ldi	r24, 0x2D	; 45
 4da:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
 4de:	b8 01       	movw	r22, r16
 4e0:	88 27       	eor	r24, r24
 4e2:	77 fd       	sbrc	r23, 7
 4e4:	80 95       	com	r24
 4e6:	98 2f       	mov	r25, r24
 4e8:	19 c0       	rjmp	.+50     	; 0x51c <__stack+0xbd>
#endif
				break;
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 4ea:	84 e0       	ldi	r24, 0x04	; 4
 4ec:	88 2e       	mov	r8, r24
 4ee:	91 2c       	mov	r9, r1
 4f0:	8e 0c       	add	r8, r14
 4f2:	9f 1c       	adc	r9, r15
 4f4:	f7 01       	movw	r30, r14
 4f6:	e0 80       	ld	r14, Z
 4f8:	f1 80       	ldd	r15, Z+1	; 0x01
 4fa:	02 81       	ldd	r16, Z+2	; 0x02
 4fc:	13 81       	ldd	r17, Z+3	; 0x03
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				if(var_num_s32<0)
 4fe:	17 ff       	sbrs	r17, 7
 500:	0b c0       	rjmp	.+22     	; 0x518 <__stack+0xb9>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   var_num_s32 = -var_num_s32;
 502:	10 95       	com	r17
 504:	00 95       	com	r16
 506:	f0 94       	com	r15
 508:	e0 94       	com	r14
 50a:	e1 1c       	adc	r14, r1
 50c:	f1 1c       	adc	r15, r1
 50e:	01 1d       	adc	r16, r1
 510:	11 1d       	adc	r17, r1
				   LCD_DisplayChar('-');
 512:	8d e2       	ldi	r24, 0x2D	; 45
 514:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
 518:	c8 01       	movw	r24, r16
 51a:	b7 01       	movw	r22, r14
 51c:	4d 2d       	mov	r20, r13
 51e:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <LCD_DisplayDecimalNumber>
 522:	74 01       	movw	r14, r8
 524:	2f c0       	rjmp	.+94     	; 0x584 <__stack+0x125>
#endif				
				break;	

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 526:	87 01       	movw	r16, r14
 528:	0e 5f       	subi	r16, 0xFE	; 254
 52a:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 52c:	f7 01       	movw	r30, r14
 52e:	60 81       	ld	r22, Z
 530:	71 81       	ldd	r23, Z+1	; 0x01
 532:	80 e0       	ldi	r24, 0x00	; 0
 534:	90 e0       	ldi	r25, 0x00	; 0
 536:	08 c0       	rjmp	.+16     	; 0x548 <__stack+0xe9>
#endif				
				break;
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 538:	87 01       	movw	r16, r14
 53a:	0c 5f       	subi	r16, 0xFC	; 252
 53c:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
 53e:	f7 01       	movw	r30, r14
 540:	60 81       	ld	r22, Z
 542:	71 81       	ldd	r23, Z+1	; 0x01
 544:	82 81       	ldd	r24, Z+2	; 0x02
 546:	93 81       	ldd	r25, Z+3	; 0x03
 548:	4d 2d       	mov	r20, r13
 54a:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <LCD_DisplayDecimalNumber>
 54e:	15 c0       	rjmp	.+42     	; 0x57a <__stack+0x11b>
#endif				
				break;

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
 550:	82 e0       	ldi	r24, 0x02	; 2
 552:	90 e0       	ldi	r25, 0x00	; 0
 554:	07 c0       	rjmp	.+14     	; 0x564 <__stack+0x105>
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
 556:	e4 e0       	ldi	r30, 0x04	; 4
 558:	f0 e0       	ldi	r31, 0x00	; 0
 55a:	ee 0e       	add	r14, r30
 55c:	ff 1e       	adc	r15, r31
 55e:	12 c0       	rjmp	.+36     	; 0x584 <__stack+0x125>
				break;


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
				var_floatNum_f32 = va_arg(argp, double);
 560:	84 e0       	ldi	r24, 0x04	; 4
 562:	90 e0       	ldi	r25, 0x00	; 0
 564:	e8 0e       	add	r14, r24
 566:	f9 1e       	adc	r15, r25
 568:	0d c0       	rjmp	.+26     	; 0x584 <__stack+0x125>
				break;


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
 56a:	87 01       	movw	r16, r14
 56c:	0e 5f       	subi	r16, 0xFE	; 254
 56e:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_LCD_DisplayString == 1)
				LCD_DisplayString(str);
 570:	f7 01       	movw	r30, r14
 572:	80 81       	ld	r24, Z
 574:	91 81       	ldd	r25, Z+1	; 0x01
 576:	0e 94 de 01 	call	0x3bc	; 0x3bc <LCD_DisplayString>
 57a:	78 01       	movw	r14, r16
 57c:	03 c0       	rjmp	.+6      	; 0x584 <__stack+0x125>
#endif				
				break;

			case '%':
				LCD_DisplayChar('%');
 57e:	85 e2       	ldi	r24, 0x25	; 37
			}
		}
		else
		{
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
 580:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 584:	08 94       	sec
 586:	a1 1c       	adc	r10, r1
 588:	b1 1c       	adc	r11, r1
 58a:	f5 01       	movw	r30, r10
 58c:	80 81       	ld	r24, Z
 58e:	88 23       	and	r24, r24
 590:	09 f0       	breq	.+2      	; 0x594 <__stack+0x135>
 592:	3b cf       	rjmp	.-394    	; 0x40a <LCD_Printf+0x34>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
 594:	cf 91       	pop	r28
 596:	df 91       	pop	r29
 598:	1f 91       	pop	r17
 59a:	0f 91       	pop	r16
 59c:	ff 90       	pop	r15
 59e:	ef 90       	pop	r14
 5a0:	df 90       	pop	r13
 5a2:	cf 90       	pop	r12
 5a4:	bf 90       	pop	r11
 5a6:	af 90       	pop	r10
 5a8:	9f 90       	pop	r9
 5aa:	8f 90       	pop	r8
 5ac:	08 95       	ret

000005ae <main>:
/* start the main program */
void main() 
{

  /* Initialize the lcd before displaying any thing on the lcd */
    LCD_Init(8,2,16);
 5ae:	88 e0       	ldi	r24, 0x08	; 8
 5b0:	62 e0       	ldi	r22, 0x02	; 2
 5b2:	40 e1       	ldi	r20, 0x10	; 16
 5b4:	0e 94 df 00 	call	0x1be	; 0x1be <LCD_Init>

  /* Display "hello, world" on first line*/
  LCD_DisplayString("hello, world");
 5b8:	85 e6       	ldi	r24, 0x65	; 101
 5ba:	90 e0       	ldi	r25, 0x00	; 0
 5bc:	0e 94 de 01 	call	0x3bc	; 0x3bc <LCD_DisplayString>

  /*Go to second line and display "good morning" */
  LCD_GoToLine(2);
 5c0:	82 e0       	ldi	r24, 0x02	; 2
 5c2:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_GoToLine>
  LCD_DisplayString("good morning");
 5c6:	82 e7       	ldi	r24, 0x72	; 114
 5c8:	90 e0       	ldi	r25, 0x00	; 0
 5ca:	0e 94 de 01 	call	0x3bc	; 0x3bc <LCD_DisplayString>
 5ce:	ff cf       	rjmp	.-2      	; 0x5ce <main+0x20>

000005d0 <__udivmodsi4>:
 5d0:	a1 e2       	ldi	r26, 0x21	; 33
 5d2:	1a 2e       	mov	r1, r26
 5d4:	aa 1b       	sub	r26, r26
 5d6:	bb 1b       	sub	r27, r27
 5d8:	fd 01       	movw	r30, r26
 5da:	0d c0       	rjmp	.+26     	; 0x5f6 <__udivmodsi4_ep>

000005dc <__udivmodsi4_loop>:
 5dc:	aa 1f       	adc	r26, r26
 5de:	bb 1f       	adc	r27, r27
 5e0:	ee 1f       	adc	r30, r30
 5e2:	ff 1f       	adc	r31, r31
 5e4:	a2 17       	cp	r26, r18
 5e6:	b3 07       	cpc	r27, r19
 5e8:	e4 07       	cpc	r30, r20
 5ea:	f5 07       	cpc	r31, r21
 5ec:	20 f0       	brcs	.+8      	; 0x5f6 <__udivmodsi4_ep>
 5ee:	a2 1b       	sub	r26, r18
 5f0:	b3 0b       	sbc	r27, r19
 5f2:	e4 0b       	sbc	r30, r20
 5f4:	f5 0b       	sbc	r31, r21

000005f6 <__udivmodsi4_ep>:
 5f6:	66 1f       	adc	r22, r22
 5f8:	77 1f       	adc	r23, r23
 5fa:	88 1f       	adc	r24, r24
 5fc:	99 1f       	adc	r25, r25
 5fe:	1a 94       	dec	r1
 600:	69 f7       	brne	.-38     	; 0x5dc <__udivmodsi4_loop>
 602:	60 95       	com	r22
 604:	70 95       	com	r23
 606:	80 95       	com	r24
 608:	90 95       	com	r25
 60a:	9b 01       	movw	r18, r22
 60c:	ac 01       	movw	r20, r24
 60e:	bd 01       	movw	r22, r26
 610:	cf 01       	movw	r24, r30
 612:	08 95       	ret

00000614 <_exit>:
 614:	f8 94       	cli

00000616 <__stop_program>:
 616:	ff cf       	rjmp	.-2      	; 0x616 <__stop_program>
