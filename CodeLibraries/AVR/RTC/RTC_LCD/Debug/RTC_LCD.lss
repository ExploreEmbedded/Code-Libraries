
RTC_LCD.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000007b0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000028  00800060  000007b0  00000844  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000005  00800088  00800088  0000086c  2**0
                  ALLOC
  3 .debug_aranges 000000a0  00000000  00000000  0000086c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000001f6  00000000  00000000  0000090c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000d87  00000000  00000000  00000b02  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000506  00000000  00000000  00001889  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000c9f  00000000  00000000  00001d8f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001d0  00000000  00000000  00002a30  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000055a  00000000  00000000  00002c00  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000653  00000000  00000000  0000315a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000090  00000000  00000000  000037ad  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 eb       	ldi	r30, 0xB0	; 176
  68:	f7 e0       	ldi	r31, 0x07	; 7
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a8 38       	cpi	r26, 0x88	; 136
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a8 e8       	ldi	r26, 0x88	; 136
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ad 38       	cpi	r26, 0x8D	; 141
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 37 03 	call	0x66e	; 0x66e <main>
  8a:	0c 94 d6 03 	jmp	0x7ac	; 0x7ac <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DELAY_sec>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  92:	40 e9       	ldi	r20, 0x90	; 144
  94:	51 e0       	ldi	r21, 0x01	; 1
  96:	09 c0       	rjmp	.+18     	; 0xaa <DELAY_sec+0x18>
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  98:	20 e1       	ldi	r18, 0x10	; 16
  9a:	37 e2       	ldi	r19, 0x27	; 39
  9c:	fa 01       	movw	r30, r20
  9e:	31 97       	sbiw	r30, 0x01	; 1
  a0:	f1 f7       	brne	.-4      	; 0x9e <DELAY_sec+0xc>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  a2:	21 50       	subi	r18, 0x01	; 1
  a4:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  a6:	d1 f7       	brne	.-12     	; 0x9c <DELAY_sec+0xa>
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
  a8:	01 97       	sbiw	r24, 0x01	; 1
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  aa:	00 97       	sbiw	r24, 0x00	; 0
  ac:	a9 f7       	brne	.-22     	; 0x98 <DELAY_sec+0x6>
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
		}
  }
  ae:	08 95       	ret

000000b0 <I2C_Init>:
 * description :This function is used to initialize the I2C module

------------------------------------------------------------------------------------*/
void I2C_Init()
{
  TWSR=0x00; //set presca1er bits to zero
  b0:	11 b8       	out	0x01, r1	; 1
  TWBR=0x50; //SCL frequency is 100K for XTAL = 7.3728M
  b2:	80 e5       	ldi	r24, 0x50	; 80
  b4:	80 b9       	out	0x00, r24	; 0
  TWCR=0x04; //enab1e TWI module
  b6:	84 e0       	ldi	r24, 0x04	; 4
  b8:	86 bf       	out	0x36, r24	; 54
}
  ba:	08 95       	ret

000000bc <I2C_Start>:
                      ____|         |____________

***************************************************************************************************/
void I2C_Start()
{
  TWCR = ((1<<TWINT) | (1<<TWSTA) | (1<<TWEN));
  bc:	84 ea       	ldi	r24, 0xA4	; 164
  be:	86 bf       	out	0x36, r24	; 54
  while (!(TWCR & (1<<TWINT)));
  c0:	06 b6       	in	r0, 0x36	; 54
  c2:	07 fe       	sbrs	r0, 7
  c4:	fd cf       	rjmp	.-6      	; 0xc0 <I2C_Start+0x4>
}
  c6:	08 95       	ret

000000c8 <I2C_Stop>:

***************************************************************************************************/

void I2C_Stop(void)
{
  TWCR = ((1<< TWINT) | (1<<TWEN) | (1<<TWSTO));
  c8:	84 e9       	ldi	r24, 0x94	; 148
  ca:	86 bf       	out	0x36, r24	; 54
  cc:	80 e9       	ldi	r24, 0x90	; 144
  ce:	91 e0       	ldi	r25, 0x01	; 1
  d0:	01 97       	sbiw	r24, 0x01	; 1
  d2:	f1 f7       	brne	.-4      	; 0xd0 <I2C_Stop+0x8>
   DELAY_us(100) ; //wait for a short time
}
  d4:	08 95       	ret

000000d6 <I2C_Write>:


***************************************************************************************************/
void I2C_Write(uint8_t var_i2cData_u8)
{
  TWDR = var_i2cData_u8 ;
  d6:	83 b9       	out	0x03, r24	; 3
  TWCR = ((1<< TWINT) | (1<<TWEN));
  d8:	84 e8       	ldi	r24, 0x84	; 132
  da:	86 bf       	out	0x36, r24	; 54
  while (!(TWCR & (1 <<TWINT)));
  dc:	06 b6       	in	r0, 0x36	; 54
  de:	07 fe       	sbrs	r0, 7
  e0:	fd cf       	rjmp	.-6      	; 0xdc <I2C_Write+0x6>
}
  e2:	08 95       	ret

000000e4 <I2C_Read>:


***************************************************************************************************/
uint8_t I2C_Read(uint8_t var_ackOption_u8)
{
 TWCR = ((1<< TWINT) | (1<<TWEN) | (var_ackOption_u8<<TWEA));
  e4:	82 95       	swap	r24
  e6:	88 0f       	add	r24, r24
  e8:	88 0f       	add	r24, r24
  ea:	80 7c       	andi	r24, 0xC0	; 192
  ec:	84 68       	ori	r24, 0x84	; 132
  ee:	86 bf       	out	0x36, r24	; 54
   while ( !(TWCR & (1 <<TWINT)));
  f0:	06 b6       	in	r0, 0x36	; 54
  f2:	07 fe       	sbrs	r0, 7
  f4:	fd cf       	rjmp	.-6      	; 0xf0 <I2C_Read+0xc>
   return TWDR;
  f6:	83 b1       	in	r24, 0x03	; 3
}
  f8:	08 95       	ret

000000fa <lcd_BusyCheck>:
static void lcd_BusyCheck()
{
	uint8_t busyflag;
#ifdef LCD_RW       //Perform Busy check if LCD_RW pin is used

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
  fa:	bf 98       	cbi	0x17, 7	; 23
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
  fc:	95 98       	cbi	0x12, 5	; 18
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
  fe:	96 9a       	sbi	0x12, 6	; 18
		M_LcdSetBit(LCD_EN); 
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 100:	30 91 8c 00 	lds	r19, 0x008C
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 104:	95 e3       	ldi	r25, 0x35	; 53
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
	do
	{

		M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
 106:	97 98       	cbi	0x12, 7	; 18
 108:	89 2f       	mov	r24, r25
 10a:	8a 95       	dec	r24
 10c:	f1 f7       	brne	.-4      	; 0x10a <lcd_BusyCheck+0x10>
		DELAY_us(10);	
		M_LcdSetBit(LCD_EN); 
 10e:	97 9a       	sbi	0x12, 7	; 18
 110:	89 2f       	mov	r24, r25
 112:	8a 95       	dec	r24
 114:	f1 f7       	brne	.-4      	; 0x112 <lcd_BusyCheck+0x18>
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
 116:	26 b3       	in	r18, 0x16	; 22


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 118:	34 30       	cpi	r19, 0x04	; 4
 11a:	41 f4       	brne	.+16     	; 0x12c <lcd_BusyCheck+0x32>
		{
			/* Perform extra dummy read for 4-bit */ 	   	
			M_LcdClearBit(LCD_EN);
 11c:	97 98       	cbi	0x12, 7	; 18
 11e:	89 2f       	mov	r24, r25
 120:	8a 95       	dec	r24
 122:	f1 f7       	brne	.-4      	; 0x120 <lcd_BusyCheck+0x26>
			DELAY_us(10);
			M_LcdSetBit(LCD_EN); 
 124:	97 9a       	sbi	0x12, 7	; 18
 126:	89 2f       	mov	r24, r25
 128:	8a 95       	dec	r24
 12a:	f1 f7       	brne	.-4      	; 0x128 <lcd_BusyCheck+0x2e>
			DELAY_us(10);
		}	
	}while(busyflag);
 12c:	27 fd       	sbrc	r18, 7
 12e:	eb cf       	rjmp	.-42     	; 0x106 <lcd_BusyCheck+0xc>

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
 130:	bf 9a       	sbi	0x17, 7	; 23
#else
	/* Busy flag cannot be read as LCD_RW is not available hence Extra delay of 1ms is added 
	  to ensure the LCD completes previous operation and ready to receive new commands/data */
	DELAY_ms(1);  
#endif
}
 132:	08 95       	ret

00000134 <lcd_SendNibble>:

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 *************************************************************************************************/
static void lcd_SendNibble(uint8_t var)
{
	util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
 134:	98 2f       	mov	r25, r24
 136:	84 ff       	sbrs	r24, 4
 138:	02 c0       	rjmp	.+4      	; 0x13e <lcd_SendNibble+0xa>
 13a:	c4 9a       	sbi	0x18, 4	; 24
 13c:	01 c0       	rjmp	.+2      	; 0x140 <lcd_SendNibble+0xc>
 13e:	c4 98       	cbi	0x18, 4	; 24
 140:	28 b3       	in	r18, 0x18	; 24
	util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
 142:	95 ff       	sbrs	r25, 5
 144:	02 c0       	rjmp	.+4      	; 0x14a <lcd_SendNibble+0x16>
 146:	c5 9a       	sbi	0x18, 5	; 24
 148:	01 c0       	rjmp	.+2      	; 0x14c <lcd_SendNibble+0x18>
 14a:	c5 98       	cbi	0x18, 5	; 24
 14c:	28 b3       	in	r18, 0x18	; 24
	util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
 14e:	96 ff       	sbrs	r25, 6
 150:	02 c0       	rjmp	.+4      	; 0x156 <lcd_SendNibble+0x22>
 152:	c6 9a       	sbi	0x18, 6	; 24
 154:	01 c0       	rjmp	.+2      	; 0x158 <lcd_SendNibble+0x24>
 156:	c6 98       	cbi	0x18, 6	; 24
 158:	98 b3       	in	r25, 0x18	; 24
	util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
 15a:	87 ff       	sbrs	r24, 7
 15c:	02 c0       	rjmp	.+4      	; 0x162 <lcd_SendNibble+0x2e>
 15e:	c7 9a       	sbi	0x18, 7	; 24
 160:	01 c0       	rjmp	.+2      	; 0x164 <lcd_SendNibble+0x30>
 162:	c7 98       	cbi	0x18, 7	; 24
 164:	88 b3       	in	r24, 0x18	; 24
 166:	08 95       	ret

00000168 <lcd_SendCmdSignals>:

 * description : This functions generates the signals for sending the var_lcdCmd_u8 to LCD
 *************************************************************************************************/
static void lcd_SendCmdSignals()
{
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 168:	95 98       	cbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
 16a:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
 16c:	97 9a       	sbi	0x12, 7	; 18
 16e:	85 e3       	ldi	r24, 0x35	; 53
 170:	8a 95       	dec	r24
 172:	f1 f7       	brne	.-4      	; 0x170 <lcd_SendCmdSignals+0x8>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 174:	97 98       	cbi	0x12, 7	; 18
}
 176:	08 95       	ret

00000178 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.				
				The behaviour is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
{
 178:	1f 93       	push	r17
 17a:	18 2f       	mov	r17, r24
	lcd_BusyCheck();
 17c:	0e 94 7d 00 	call	0xfa	; 0xfa <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 180:	80 91 8c 00 	lds	r24, 0x008C
 184:	88 30       	cpi	r24, 0x08	; 8
 186:	11 f4       	brne	.+4      	; 0x18c <LCD_CmdWrite+0x14>
	{

		M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
 188:	18 bb       	out	0x18, r17	; 24
 18a:	0c c0       	rjmp	.+24     	; 0x1a4 <LCD_CmdWrite+0x2c>
		lcd_SendCmdSignals();  // Signals for command write operation
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 18c:	84 30       	cpi	r24, 0x04	; 4
 18e:	61 f4       	brne	.+24     	; 0x1a8 <LCD_CmdWrite+0x30>
	{
		lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
 190:	81 2f       	mov	r24, r17
 192:	0e 94 9a 00 	call	0x134	; 0x134 <lcd_SendNibble>
		lcd_SendCmdSignals(); // Signals for command write operation
 196:	0e 94 b4 00 	call	0x168	; 0x168 <lcd_SendCmdSignals>

		lcd_SendNibble(var_lcdCmd_u8 << 4);
 19a:	81 2f       	mov	r24, r17
 19c:	82 95       	swap	r24
 19e:	80 7f       	andi	r24, 0xF0	; 240
 1a0:	0e 94 9a 00 	call	0x134	; 0x134 <lcd_SendNibble>
		lcd_SendCmdSignals();
 1a4:	0e 94 b4 00 	call	0x168	; 0x168 <lcd_SendCmdSignals>
	}
}
 1a8:	1f 91       	pop	r17
 1aa:	08 95       	ret

000001ac <LCD_GoToNextLine>:
 ***************************************************************************************************/
void  LCD_GoToNextLine()
{
	/*Increment the current line number.
	  In case it exceeds the limit, rool it back to first line */
	VAR_LcdTrackLineNum_U8++;
 1ac:	80 91 89 00 	lds	r24, 0x0089
 1b0:	8f 5f       	subi	r24, 0xFF	; 255
 1b2:	80 93 89 00 	sts	0x0089, r24
	VAR_LcdTrackCursorPos_U8 = 0x00;
 1b6:	10 92 88 00 	sts	0x0088, r1
	if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 1ba:	90 91 8a 00 	lds	r25, 0x008A
 1be:	98 17       	cp	r25, r24
 1c0:	18 f4       	brcc	.+6      	; 0x1c8 <LCD_GoToNextLine+0x1c>
		VAR_LcdTrackLineNum_U8 = 0x01;
 1c2:	81 e0       	ldi	r24, 0x01	; 1
 1c4:	80 93 89 00 	sts	0x0089, r24
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
 1c8:	e0 91 89 00 	lds	r30, 0x0089
 1cc:	f0 e0       	ldi	r31, 0x00	; 0
 1ce:	e0 5a       	subi	r30, 0xA0	; 160
 1d0:	ff 4f       	sbci	r31, 0xFF	; 255
 1d2:	80 81       	ld	r24, Z
 1d4:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_CmdWrite>
}
 1d8:	08 95       	ret

000001da <LCD_GoToLine>:
           mENUM_LcdLineTwo,
           mENUM_LcdLineThree,
           mENUM_LcdLineFour,
 ***************************************************************************************************/
void LCD_GoToLine(uint8_t var_lineNumber_u8)
{
 1da:	e8 2f       	mov	r30, r24
	if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
 1dc:	80 91 8a 00 	lds	r24, 0x008A
 1e0:	8e 17       	cp	r24, r30
 1e2:	50 f0       	brcs	.+20     	; 0x1f8 <LCD_GoToLine+0x1e>
	{
		/* If the line number is within range then
	       Move the Cursor to beginning of the specified line */
		VAR_LcdTrackCursorPos_U8 = 0x00;
 1e4:	10 92 88 00 	sts	0x0088, r1
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 1e8:	e0 93 89 00 	sts	0x0089, r30
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
 1ec:	f0 e0       	ldi	r31, 0x00	; 0
 1ee:	e0 5a       	subi	r30, 0xA0	; 160
 1f0:	ff 4f       	sbci	r31, 0xFF	; 255
 1f2:	80 81       	ld	r24, Z
 1f4:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_CmdWrite>
 1f8:	08 95       	ret

000001fa <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ***************************************************************************************************/
void LCD_Clear()
{
	LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
 1fa:	81 e0       	ldi	r24, 0x01	; 1
 1fc:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_CmdWrite>
	LCD_GoToLine(mENUM_LcdLineOne);
 200:	81 e0       	ldi	r24, 0x01	; 1
 202:	0e 94 ed 00 	call	0x1da	; 0x1da <LCD_GoToLine>
}
 206:	08 95       	ret

00000208 <LCD_Init>:

 * description  :This function is used to initialize the lcd.
                 *It initializes the LCD for selected mode(4/8-bit) and Type(16x2/16x1 etc)
**************************************************************************************************/
void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
{
 208:	0f 93       	push	r16
 20a:	1f 93       	push	r17
 20c:	58 2f       	mov	r21, r24


	M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
 20e:	8f ef       	ldi	r24, 0xFF	; 255
 210:	87 bb       	out	0x17, r24	; 23
	M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
 212:	81 bb       	out	0x11, r24	; 17
	STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
 214:	50 93 8c 00 	sts	0x008C, r21
	STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
 218:	40 93 8b 00 	sts	0x008B, r20
	STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
 21c:	60 93 8a 00 	sts	0x008A, r22
	if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
 220:	63 30       	cpi	r22, 0x03	; 3
 222:	40 f0       	brcs	.+16     	; 0x234 <LCD_Init+0x2c>
	{
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
 224:	84 2f       	mov	r24, r20
 226:	8f 70       	andi	r24, 0x0F	; 15
 228:	80 57       	subi	r24, 0x70	; 112
 22a:	80 93 63 00 	sts	0x0063, r24
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
 22e:	80 5c       	subi	r24, 0xC0	; 192
 230:	80 93 64 00 	sts	0x0064, r24
 234:	88 ee       	ldi	r24, 0xE8	; 232
 236:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 238:	20 e9       	ldi	r18, 0x90	; 144
 23a:	31 e0       	ldi	r19, 0x01	; 1
 23c:	f9 01       	movw	r30, r18
 23e:	31 97       	sbiw	r30, 0x01	; 1
 240:	f1 f7       	brne	.-4      	; 0x23e <LCD_Init+0x36>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 242:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 244:	d9 f7       	brne	.-10     	; 0x23c <LCD_Init+0x34>
	}

	DELAY_ms(100);

	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 246:	58 30       	cpi	r21, 0x08	; 8
 248:	11 f4       	brne	.+4      	; 0x24e <LCD_Init+0x46>
	{
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 24a:	88 e3       	ldi	r24, 0x38	; 56
 24c:	2b c0       	rjmp	.+86     	; 0x2a4 <LCD_Init+0x9c>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 24e:	54 30       	cpi	r21, 0x04	; 4
 250:	59 f5       	brne	.+86     	; 0x2a8 <LCD_Init+0xa0>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset()
{
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendNibble(0x30);
 252:	80 e3       	ldi	r24, 0x30	; 48
 254:	0e 94 9a 00 	call	0x134	; 0x134 <lcd_SendNibble>
	lcd_SendCmdSignals();
 258:	0e 94 b4 00 	call	0x168	; 0x168 <lcd_SendCmdSignals>
 25c:	88 ee       	ldi	r24, 0xE8	; 232
 25e:	93 e0       	ldi	r25, 0x03	; 3
 260:	20 e9       	ldi	r18, 0x90	; 144
 262:	31 e0       	ldi	r19, 0x01	; 1
 264:	f9 01       	movw	r30, r18
 266:	31 97       	sbiw	r30, 0x01	; 1
 268:	f1 f7       	brne	.-4      	; 0x266 <LCD_Init+0x5e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 26a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 26c:	d9 f7       	brne	.-10     	; 0x264 <LCD_Init+0x5c>
	DELAY_ms(100);
	lcd_SendNibble(0x30);
 26e:	80 e3       	ldi	r24, 0x30	; 48
 270:	0e 94 9a 00 	call	0x134	; 0x134 <lcd_SendNibble>
	lcd_SendCmdSignals();
 274:	0e 94 b4 00 	call	0x168	; 0x168 <lcd_SendCmdSignals>
 278:	00 e2       	ldi	r16, 0x20	; 32
 27a:	13 e0       	ldi	r17, 0x03	; 3
 27c:	c8 01       	movw	r24, r16
 27e:	01 97       	sbiw	r24, 0x01	; 1
 280:	f1 f7       	brne	.-4      	; 0x27e <LCD_Init+0x76>
	DELAY_us(200);
	lcd_SendNibble(0x30);
 282:	80 e3       	ldi	r24, 0x30	; 48
 284:	0e 94 9a 00 	call	0x134	; 0x134 <lcd_SendNibble>
	lcd_SendCmdSignals();
 288:	0e 94 b4 00 	call	0x168	; 0x168 <lcd_SendCmdSignals>
 28c:	c8 01       	movw	r24, r16
 28e:	01 97       	sbiw	r24, 0x01	; 1
 290:	f1 f7       	brne	.-4      	; 0x28e <LCD_Init+0x86>
	DELAY_us(200);
	lcd_SendNibble(0x20);
 292:	80 e2       	ldi	r24, 0x20	; 32
 294:	0e 94 9a 00 	call	0x134	; 0x134 <lcd_SendNibble>
	lcd_SendCmdSignals();
 298:	0e 94 b4 00 	call	0x168	; 0x168 <lcd_SendCmdSignals>
 29c:	c8 01       	movw	r24, r16
 29e:	01 97       	sbiw	r24, 0x01	; 1
 2a0:	f1 f7       	brne	.-4      	; 0x29e <LCD_Init+0x96>
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
	{
		lcd_Reset();
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 2a2:	88 e2       	ldi	r24, 0x28	; 40
 2a4:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);	 // Display ON cursor ON
 2a8:	8e e0       	ldi	r24, 0x0E	; 14
 2aa:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_CmdWrite>
	LCD_Clear();	                         // Clear the LCD and go to First line First Position
 2ae:	0e 94 fd 00 	call	0x1fa	; 0x1fa <LCD_Clear>
}
 2b2:	1f 91       	pop	r17
 2b4:	0f 91       	pop	r16
 2b6:	08 95       	ret

000002b8 <lcd_SendDataSignals>:

 * description : This functions generates the signals for sending the Data to LCD
 *************************************************************************************************/
static void lcd_SendDataSignals()
{
	M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
 2b8:	95 9a       	sbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
 2ba:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
 2bc:	97 9a       	sbi	0x12, 7	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 2be:	85 e3       	ldi	r24, 0x35	; 53
 2c0:	8a 95       	dec	r24
 2c2:	f1 f7       	brne	.-4      	; 0x2c0 <lcd_SendDataSignals+0x8>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 2c4:	97 98       	cbi	0x12, 7	; 18
}
 2c6:	08 95       	ret

000002c8 <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
void LCD_DisplayChar(char var_lcdData_u8)
{
 2c8:	1f 93       	push	r17
 2ca:	18 2f       	mov	r17, r24
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
 2cc:	90 91 88 00 	lds	r25, 0x0088
 2d0:	80 91 8b 00 	lds	r24, 0x008B
 2d4:	98 17       	cp	r25, r24
 2d6:	10 f4       	brcc	.+4      	; 0x2dc <LCD_DisplayChar+0x14>
 2d8:	1a 30       	cpi	r17, 0x0A	; 10
 2da:	21 f4       	brne	.+8      	; 0x2e4 <LCD_DisplayChar+0x1c>
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 2dc:	0e 94 d6 00 	call	0x1ac	; 0x1ac <LCD_GoToNextLine>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 2e0:	1a 30       	cpi	r17, 0x0A	; 10
 2e2:	d9 f0       	breq	.+54     	; 0x31a <LCD_DisplayChar+0x52>

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void lcd_DataWrite( uint8_t dat)
{
	lcd_BusyCheck();
 2e4:	0e 94 7d 00 	call	0xfa	; 0xfa <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 2e8:	80 91 8c 00 	lds	r24, 0x008C
 2ec:	88 30       	cpi	r24, 0x08	; 8
 2ee:	11 f4       	brne	.+4      	; 0x2f4 <LCD_DisplayChar+0x2c>
	{
		M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
 2f0:	18 bb       	out	0x18, r17	; 24
 2f2:	0c c0       	rjmp	.+24     	; 0x30c <LCD_DisplayChar+0x44>
		lcd_SendDataSignals();  // Signals for data write operation
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 2f4:	84 30       	cpi	r24, 0x04	; 4
 2f6:	61 f4       	brne	.+24     	; 0x310 <LCD_DisplayChar+0x48>
	{
		lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
 2f8:	81 2f       	mov	r24, r17
 2fa:	0e 94 9a 00 	call	0x134	; 0x134 <lcd_SendNibble>
		lcd_SendDataSignals();  // Signals for data write operation
 2fe:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <lcd_SendDataSignals>

		lcd_SendNibble(dat << 4);
 302:	81 2f       	mov	r24, r17
 304:	82 95       	swap	r24
 306:	80 7f       	andi	r24, 0xF0	; 240
 308:	0e 94 9a 00 	call	0x134	; 0x134 <lcd_SendNibble>
		lcd_SendDataSignals();
 30c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <lcd_SendDataSignals>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
 310:	80 91 88 00 	lds	r24, 0x0088
 314:	8f 5f       	subi	r24, 0xFF	; 255
 316:	80 93 88 00 	sts	0x0088, r24
	}
}
 31a:	1f 91       	pop	r17
 31c:	08 95       	ret

0000031e <LCD_DisplayHexNumber>:
				2.(0x12AB,6) then 6-digits ie. 0012AB will be displayed
				3.(0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.
 ***************************************************************************************************/
#if ( Enable_LCD_DisplayHexNumber == 1 ) 
void LCD_DisplayHexNumber(uint32_t var_hexNumber_u32,uint8_t var_numOfDigitsToDisplay_u8)
{
 31e:	0f 93       	push	r16
 320:	1f 93       	push	r17
 322:	df 93       	push	r29
 324:	cf 93       	push	r28
 326:	cd b7       	in	r28, 0x3d	; 61
 328:	de b7       	in	r29, 0x3e	; 62
 32a:	2b 97       	sbiw	r28, 0x0b	; 11
 32c:	0f b6       	in	r0, 0x3f	; 63
 32e:	f8 94       	cli
 330:	de bf       	out	0x3e, r29	; 62
 332:	0f be       	out	0x3f, r0	; 63
 334:	cd bf       	out	0x3d, r28	; 61
 336:	8b 01       	movw	r16, r22
 338:	9c 01       	movw	r18, r24
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
 33a:	61 15       	cp	r22, r1
 33c:	71 05       	cpc	r23, r1
 33e:	81 05       	cpc	r24, r1
 340:	91 05       	cpc	r25, r1
 342:	29 f0       	breq	.+10     	; 0x34e <LCD_DisplayHexNumber+0x30>
 344:	90 e0       	ldi	r25, 0x00	; 0
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
                Ex: var_num_u32 is 0x123 and user wants five digits then 00123 has to be displayed */
				a[i]=0x00;
 346:	be 01       	movw	r22, r28
 348:	6f 5f       	subi	r22, 0xFF	; 255
 34a:	7f 4f       	sbci	r23, 0xFF	; 255
 34c:	25 c0       	rjmp	.+74     	; 0x398 <LCD_DisplayHexNumber+0x7a>
#if ( Enable_LCD_DisplayHexNumber == 1 ) 
void LCD_DisplayHexNumber(uint32_t var_hexNumber_u32,uint8_t var_numOfDigitsToDisplay_u8)
{
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
 34e:	fe 01       	movw	r30, r28
 350:	31 96       	adiw	r30, 0x01	; 1
 352:	90 e0       	ldi	r25, 0x00	; 0
 354:	02 c0       	rjmp	.+4      	; 0x35a <LCD_DisplayHexNumber+0x3c>
	{
		/* If the number zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		    a[i] = 0x00;
 356:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
	{
		/* If the number zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 358:	9f 5f       	subi	r25, 0xFF	; 255
 35a:	94 17       	cp	r25, r20
 35c:	70 f5       	brcc	.+92     	; 0x3ba <LCD_DisplayHexNumber+0x9c>
 35e:	9a 30       	cpi	r25, 0x0A	; 10
 360:	d1 f7       	brne	.-12     	; 0x356 <LCD_DisplayHexNumber+0x38>
 362:	2b c0       	rjmp	.+86     	; 0x3ba <LCD_DisplayHexNumber+0x9c>
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_hexNumber_u32!=0)
 364:	01 15       	cp	r16, r1
 366:	11 05       	cpc	r17, r1
 368:	21 05       	cpc	r18, r1
 36a:	31 05       	cpc	r19, r1
 36c:	71 f0       	breq	.+28     	; 0x38a <LCD_DisplayHexNumber+0x6c>
			{
				/* Extract the digits from the number till it becomes zero.
			   First get the lower nibble and shift the number 4 times.
			   if var_num_u32 = 0xABC then extracted digit will be 0x0C and number will become 0xAB.
			   The process continues till it becomes zero or max digits reached*/
				a[i]=(uint8_t)(var_hexNumber_u32 & 0x0f);
 36e:	fb 01       	movw	r30, r22
 370:	e9 0f       	add	r30, r25
 372:	f1 1d       	adc	r31, r1
 374:	80 2f       	mov	r24, r16
 376:	8f 70       	andi	r24, 0x0F	; 15
 378:	80 83       	st	Z, r24
				var_hexNumber_u32=var_hexNumber_u32 >> 4;
 37a:	84 e0       	ldi	r24, 0x04	; 4
 37c:	36 95       	lsr	r19
 37e:	27 95       	ror	r18
 380:	17 95       	ror	r17
 382:	07 95       	ror	r16
 384:	8a 95       	dec	r24
 386:	d1 f7       	brne	.-12     	; 0x37c <LCD_DisplayHexNumber+0x5e>
 388:	06 c0       	rjmp	.+12     	; 0x396 <LCD_DisplayHexNumber+0x78>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 38a:	4b 30       	cpi	r20, 0x0B	; 11
 38c:	b0 f4       	brcc	.+44     	; 0x3ba <LCD_DisplayHexNumber+0x9c>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
                Ex: var_num_u32 is 0x123 and user wants five digits then 00123 has to be displayed */
				a[i]=0x00;
 38e:	fb 01       	movw	r30, r22
 390:	e9 0f       	add	r30, r25
 392:	f1 1d       	adc	r31, r1
 394:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		    a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 396:	9f 5f       	subi	r25, 0xFF	; 255
 398:	94 17       	cp	r25, r20
 39a:	20 f3       	brcs	.-56     	; 0x364 <LCD_DisplayHexNumber+0x46>
 39c:	0e c0       	rjmp	.+28     	; 0x3ba <LCD_DisplayHexNumber+0x9c>
	}

	while(i!=0)
	{
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
 39e:	fe 01       	movw	r30, r28
 3a0:	e9 0f       	add	r30, r25
 3a2:	f1 1d       	adc	r31, r1
 3a4:	80 81       	ld	r24, Z
 3a6:	8a 30       	cpi	r24, 0x0A	; 10
 3a8:	10 f0       	brcs	.+4      	; 0x3ae <LCD_DisplayHexNumber+0x90>
 3aa:	89 5c       	subi	r24, 0xC9	; 201
 3ac:	01 c0       	rjmp	.+2      	; 0x3b0 <LCD_DisplayHexNumber+0x92>
 3ae:	80 5d       	subi	r24, 0xD0	; 208
 3b0:	9b 87       	std	Y+11, r25	; 0x0b
 3b2:	0e 94 64 01 	call	0x2c8	; 0x2c8 <LCD_DisplayChar>
		i--;
 3b6:	9b 85       	ldd	r25, Y+11	; 0x0b
 3b8:	91 50       	subi	r25, 0x01	; 1
				a[i]=0x00;
			}
		}
	}

	while(i!=0)
 3ba:	99 23       	and	r25, r25
 3bc:	81 f7       	brne	.-32     	; 0x39e <LCD_DisplayHexNumber+0x80>
	{
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
		i--;
	}
}
 3be:	2b 96       	adiw	r28, 0x0b	; 11
 3c0:	0f b6       	in	r0, 0x3f	; 63
 3c2:	f8 94       	cli
 3c4:	de bf       	out	0x3e, r29	; 62
 3c6:	0f be       	out	0x3f, r0	; 63
 3c8:	cd bf       	out	0x3d, r28	; 61
 3ca:	cf 91       	pop	r28
 3cc:	df 91       	pop	r29
 3ce:	1f 91       	pop	r17
 3d0:	0f 91       	pop	r16
 3d2:	08 95       	ret

000003d4 <LCD_Printf>:
	     %12b: will display the 12-LSB of the number
		 %d: Will display the exact digits of the number
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
 3d4:	bf 92       	push	r11
 3d6:	cf 92       	push	r12
 3d8:	df 92       	push	r13
 3da:	ef 92       	push	r14
 3dc:	ff 92       	push	r15
 3de:	0f 93       	push	r16
 3e0:	1f 93       	push	r17
 3e2:	df 93       	push	r29
 3e4:	cf 93       	push	r28
 3e6:	cd b7       	in	r28, 0x3d	; 61
 3e8:	de b7       	in	r29, 0x3e	; 62
 3ea:	2e e0       	ldi	r18, 0x0E	; 14
 3ec:	e2 2e       	mov	r14, r18
 3ee:	f1 2c       	mov	r15, r1
 3f0:	ec 0e       	add	r14, r28
 3f2:	fd 1e       	adc	r15, r29
 3f4:	8c 85       	ldd	r24, Y+12	; 0x0c
 3f6:	9d 85       	ldd	r25, Y+13	; 0x0d
 3f8:	9c 01       	movw	r18, r24
 3fa:	69 01       	movw	r12, r18
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 3fc:	9a e0       	ldi	r25, 0x0A	; 10
 3fe:	b9 2e       	mov	r11, r25
 400:	7d c0       	rjmp	.+250    	; 0x4fc <__stack+0x9d>
	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
	{

		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
 402:	85 32       	cpi	r24, 0x25	; 37
 404:	09 f0       	breq	.+2      	; 0x408 <LCD_Printf+0x34>
 406:	75 c0       	rjmp	.+234    	; 0x4f2 <__stack+0x93>
		{
		    ptr++;
 408:	08 94       	sec
 40a:	c1 1c       	adc	r12, r1
 40c:	d1 1c       	adc	r13, r1
		    ch = *ptr;
 40e:	f6 01       	movw	r30, r12
 410:	90 81       	ld	r25, Z
		   if((ch>=0x30) && (ch<=0x39))
 412:	89 2f       	mov	r24, r25
 414:	80 53       	subi	r24, 0x30	; 48
 416:	8a 30       	cpi	r24, 0x0A	; 10
 418:	10 f0       	brcs	.+4      	; 0x41e <LCD_Printf+0x4a>
 41a:	4f ef       	ldi	r20, 0xFF	; 255
 41c:	0f c0       	rjmp	.+30     	; 0x43c <LCD_Printf+0x68>
 41e:	40 e0       	ldi	r20, 0x00	; 0
 420:	09 c0       	rjmp	.+18     	; 0x434 <LCD_Printf+0x60>
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 422:	4b 9d       	mul	r20, r11
 424:	40 2d       	mov	r20, r0
 426:	11 24       	eor	r1, r1
 428:	48 0f       	add	r20, r24
				   ptr++;
 42a:	08 94       	sec
 42c:	c1 1c       	adc	r12, r1
 42e:	d1 1c       	adc	r13, r1
				   ch = *ptr;
 430:	f6 01       	movw	r30, r12
 432:	90 81       	ld	r25, Z
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
 434:	89 2f       	mov	r24, r25
 436:	80 53       	subi	r24, 0x30	; 48
 438:	8a 30       	cpi	r24, 0x0A	; 10
 43a:	98 f3       	brcs	.-26     	; 0x422 <LCD_Printf+0x4e>
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
 43c:	98 35       	cpi	r25, 0x58	; 88
 43e:	e1 f1       	breq	.+120    	; 0x4b8 <__stack+0x59>
 440:	99 35       	cpi	r25, 0x59	; 89
 442:	b8 f4       	brcc	.+46     	; 0x472 <__stack+0x13>
 444:	94 34       	cpi	r25, 0x44	; 68
 446:	09 f4       	brne	.+2      	; 0x44a <LCD_Printf+0x76>
 448:	46 c0       	rjmp	.+140    	; 0x4d6 <__stack+0x77>
 44a:	95 34       	cpi	r25, 0x45	; 69
 44c:	48 f4       	brcc	.+18     	; 0x460 <__stack+0x1>
 44e:	92 34       	cpi	r25, 0x42	; 66
 450:	09 f4       	brne	.+2      	; 0x454 <LCD_Printf+0x80>
 452:	41 c0       	rjmp	.+130    	; 0x4d6 <__stack+0x77>
 454:	93 34       	cpi	r25, 0x43	; 67
 456:	f8 f4       	brcc	.+62     	; 0x496 <__stack+0x37>
 458:	95 32       	cpi	r25, 0x25	; 37
 45a:	09 f0       	breq	.+2      	; 0x45e <LCD_Printf+0x8a>
 45c:	4c c0       	rjmp	.+152    	; 0x4f6 <__stack+0x97>
 45e:	48 c0       	rjmp	.+144    	; 0x4f0 <__stack+0x91>
 460:	93 35       	cpi	r25, 0x53	; 83
 462:	09 f4       	brne	.+2      	; 0x466 <__stack+0x7>
 464:	40 c0       	rjmp	.+128    	; 0x4e6 <__stack+0x87>
 466:	95 35       	cpi	r25, 0x55	; 85
 468:	b1 f1       	breq	.+108    	; 0x4d6 <__stack+0x77>
 46a:	96 34       	cpi	r25, 0x46	; 70
 46c:	09 f0       	breq	.+2      	; 0x470 <__stack+0x11>
 46e:	43 c0       	rjmp	.+134    	; 0x4f6 <__stack+0x97>
 470:	35 c0       	rjmp	.+106    	; 0x4dc <__stack+0x7d>
 472:	96 36       	cpi	r25, 0x66	; 102
 474:	99 f1       	breq	.+102    	; 0x4dc <__stack+0x7d>
 476:	97 36       	cpi	r25, 0x67	; 103
 478:	38 f4       	brcc	.+14     	; 0x488 <__stack+0x29>
 47a:	93 36       	cpi	r25, 0x63	; 99
 47c:	61 f0       	breq	.+24     	; 0x496 <__stack+0x37>
 47e:	94 36       	cpi	r25, 0x64	; 100
 480:	39 f1       	breq	.+78     	; 0x4d0 <__stack+0x71>
 482:	92 36       	cpi	r25, 0x62	; 98
 484:	c1 f5       	brne	.+112    	; 0x4f6 <__stack+0x97>
 486:	24 c0       	rjmp	.+72     	; 0x4d0 <__stack+0x71>
 488:	95 37       	cpi	r25, 0x75	; 117
 48a:	11 f1       	breq	.+68     	; 0x4d0 <__stack+0x71>
 48c:	98 37       	cpi	r25, 0x78	; 120
 48e:	59 f0       	breq	.+22     	; 0x4a6 <__stack+0x47>
 490:	93 37       	cpi	r25, 0x73	; 115
 492:	89 f5       	brne	.+98     	; 0x4f6 <__stack+0x97>
 494:	28 c0       	rjmp	.+80     	; 0x4e6 <__stack+0x87>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 496:	87 01       	movw	r16, r14
 498:	0e 5f       	subi	r16, 0xFE	; 254
 49a:	1f 4f       	sbci	r17, 0xFF	; 255
				LCD_DisplayChar(ch);
 49c:	f7 01       	movw	r30, r14
 49e:	80 81       	ld	r24, Z
 4a0:	0e 94 64 01 	call	0x2c8	; 0x2c8 <LCD_DisplayChar>
 4a4:	13 c0       	rjmp	.+38     	; 0x4cc <__stack+0x6d>
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;			

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u16 = va_arg(argp, uint16_t);
 4a6:	87 01       	movw	r16, r14
 4a8:	0e 5f       	subi	r16, 0xFE	; 254
 4aa:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_LCD_DisplayHexNumber == 1)				
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 4ac:	f7 01       	movw	r30, r14
 4ae:	60 81       	ld	r22, Z
 4b0:	71 81       	ldd	r23, Z+1	; 0x01
 4b2:	80 e0       	ldi	r24, 0x00	; 0
 4b4:	90 e0       	ldi	r25, 0x00	; 0
 4b6:	08 c0       	rjmp	.+16     	; 0x4c8 <__stack+0x69>
#endif				
				break;

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u32 = va_arg(argp, uint32_t);
 4b8:	87 01       	movw	r16, r14
 4ba:	0c 5f       	subi	r16, 0xFC	; 252
 4bc:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_LCD_DisplayHexNumber == 1)						
				LCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
 4be:	f7 01       	movw	r30, r14
 4c0:	60 81       	ld	r22, Z
 4c2:	71 81       	ldd	r23, Z+1	; 0x01
 4c4:	82 81       	ldd	r24, Z+2	; 0x02
 4c6:	93 81       	ldd	r25, Z+3	; 0x03
 4c8:	0e 94 8f 01 	call	0x31e	; 0x31e <LCD_DisplayHexNumber>
 4cc:	78 01       	movw	r14, r16
 4ce:	13 c0       	rjmp	.+38     	; 0x4f6 <__stack+0x97>
#endif				
				break;

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
 4d0:	82 e0       	ldi	r24, 0x02	; 2
 4d2:	90 e0       	ldi	r25, 0x00	; 0
 4d4:	05 c0       	rjmp	.+10     	; 0x4e0 <__stack+0x81>
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
 4d6:	e4 e0       	ldi	r30, 0x04	; 4
 4d8:	f0 e0       	ldi	r31, 0x00	; 0
 4da:	07 c0       	rjmp	.+14     	; 0x4ea <__stack+0x8b>
				break;


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
				var_floatNum_f32 = va_arg(argp, double);
 4dc:	84 e0       	ldi	r24, 0x04	; 4
 4de:	90 e0       	ldi	r25, 0x00	; 0
 4e0:	e8 0e       	add	r14, r24
 4e2:	f9 1e       	adc	r15, r25
 4e4:	08 c0       	rjmp	.+16     	; 0x4f6 <__stack+0x97>
				break;


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
 4e6:	e2 e0       	ldi	r30, 0x02	; 2
 4e8:	f0 e0       	ldi	r31, 0x00	; 0
 4ea:	ee 0e       	add	r14, r30
 4ec:	ff 1e       	adc	r15, r31
 4ee:	03 c0       	rjmp	.+6      	; 0x4f6 <__stack+0x97>
				LCD_DisplayString(str);
#endif				
				break;

			case '%':
				LCD_DisplayChar('%');
 4f0:	85 e2       	ldi	r24, 0x25	; 37
			}
		}
		else
		{
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
 4f2:	0e 94 64 01 	call	0x2c8	; 0x2c8 <LCD_DisplayChar>
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 4f6:	08 94       	sec
 4f8:	c1 1c       	adc	r12, r1
 4fa:	d1 1c       	adc	r13, r1
 4fc:	f6 01       	movw	r30, r12
 4fe:	80 81       	ld	r24, Z
 500:	88 23       	and	r24, r24
 502:	09 f0       	breq	.+2      	; 0x506 <__stack+0xa7>
 504:	7e cf       	rjmp	.-260    	; 0x402 <LCD_Printf+0x2e>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
 506:	cf 91       	pop	r28
 508:	df 91       	pop	r29
 50a:	1f 91       	pop	r17
 50c:	0f 91       	pop	r16
 50e:	ff 90       	pop	r15
 510:	ef 90       	pop	r14
 512:	df 90       	pop	r13
 514:	cf 90       	pop	r12
 516:	bf 90       	pop	r11
 518:	08 95       	ret

0000051a <RTC_SetDate>:
                 The new Date is updated into the non volatile memory of Ds1307.
		Note: The I/P arguments should of BCD, 
	      like 0x15,0x08,0x47 for 15th day,8th month and 47th year.				 
***************************************************************************************************/
void RTC_SetDate(uint8_t var_day_u8, uint8_t var_month_u8, uint8_t var_year_u8)
{
 51a:	ff 92       	push	r15
 51c:	0f 93       	push	r16
 51e:	1f 93       	push	r17
 520:	18 2f       	mov	r17, r24
 522:	06 2f       	mov	r16, r22
 524:	f4 2e       	mov	r15, r20
	I2C_Start();                          // Start I2C communication
 526:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Start>

	I2C_Write(C_Ds1307WriteMode_U8);	  // connect to DS1307 by sending its ID on I2c Bus
 52a:	80 ed       	ldi	r24, 0xD0	; 208
 52c:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>
	I2C_Write(C_Ds1307DateRegAddress_U8); // Request DAY RAM address at 04H
 530:	84 e0       	ldi	r24, 0x04	; 4
 532:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>

	I2C_Write(var_day_u8);			      // Write date on RAM address 04H
 536:	81 2f       	mov	r24, r17
 538:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>
	I2C_Write(var_month_u8);			      // Write month on RAM address 05H
 53c:	80 2f       	mov	r24, r16
 53e:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>
	I2C_Write(var_year_u8);			      // Write year on RAM address 06h
 542:	8f 2d       	mov	r24, r15
 544:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>

	I2C_Stop();				              // Stop I2C communication after Setting the Date
 548:	0e 94 64 00 	call	0xc8	; 0xc8 <I2C_Stop>
}
 54c:	1f 91       	pop	r17
 54e:	0f 91       	pop	r16
 550:	ff 90       	pop	r15
 552:	08 95       	ret

00000554 <RTC_SetTime>:
                 The new time is updated into the non volatile memory of Ds1307.
	Note: The I/P arguments should of BCD, 
	      like 0x12,0x39,0x26 for 12hr,39min and 26sec.			 
***************************************************************************************************/
void RTC_SetTime(uint8_t var_hour_u8, uint8_t var_min_u8, uint8_t var_sec_u8)
{
 554:	ff 92       	push	r15
 556:	0f 93       	push	r16
 558:	1f 93       	push	r17
 55a:	f8 2e       	mov	r15, r24
 55c:	06 2f       	mov	r16, r22
 55e:	14 2f       	mov	r17, r20
	I2C_Start();                            // Start I2C communication
 560:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Start>

	I2C_Write(C_Ds1307WriteMode_U8);        // connect to DS1307 by sending its ID on I2c Bus
 564:	80 ed       	ldi	r24, 0xD0	; 208
 566:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>
	I2C_Write(C_Ds1307SecondRegAddress_U8); // Select the SEC RAM address
 56a:	80 e0       	ldi	r24, 0x00	; 0
 56c:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>

	I2C_Write(var_sec_u8);			        // Write sec from RAM address 00H
 570:	81 2f       	mov	r24, r17
 572:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>
	I2C_Write(var_min_u8);			        // Write min from RAM address 01H
 576:	80 2f       	mov	r24, r16
 578:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>
	I2C_Write(var_hour_u8);			        // Write hour from RAM address 02H
 57c:	8f 2d       	mov	r24, r15
 57e:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>

	I2C_Stop();           	                // Stop I2C communication after Setting the Time
 582:	0e 94 64 00 	call	0xc8	; 0xc8 <I2C_Stop>
}
 586:	1f 91       	pop	r17
 588:	0f 91       	pop	r16
 58a:	ff 90       	pop	r15
 58c:	08 95       	ret

0000058e <RTC_GetDate>:

	Note: The date read from Ds1307 will be of BCD format, 
	      like 0x15,0x08,0x47 for 15th day,8th month and 47th year.			  
***************************************************************************************************/
void RTC_GetDate(uint8_t *ptr_day_u8,uint8_t *ptr_month_u8,uint8_t *ptr_year_u8)
{
 58e:	cf 92       	push	r12
 590:	df 92       	push	r13
 592:	ef 92       	push	r14
 594:	ff 92       	push	r15
 596:	0f 93       	push	r16
 598:	1f 93       	push	r17
 59a:	8c 01       	movw	r16, r24
 59c:	7b 01       	movw	r14, r22
 59e:	6a 01       	movw	r12, r20
	I2C_Start();                          // Start I2C communication
 5a0:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Start>

	I2C_Write(C_Ds1307WriteMode_U8);	      // connect to DS1307 by sending its ID on I2c Bus
 5a4:	80 ed       	ldi	r24, 0xD0	; 208
 5a6:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>
	I2C_Write(C_Ds1307DateRegAddress_U8); // Request DAY RAM address at 04H
 5aa:	84 e0       	ldi	r24, 0x04	; 4
 5ac:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>

	I2C_Stop();			                  // Stop I2C communication after selecting DAY Register
 5b0:	0e 94 64 00 	call	0xc8	; 0xc8 <I2C_Stop>


	I2C_Start();		                  // Start I2C communication
 5b4:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Start>
	I2C_Write(C_Ds1307ReadMode_U8);	      // connect to DS1307(Read mode) by sending its ID
 5b8:	81 ed       	ldi	r24, 0xD1	; 209
 5ba:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>

	*ptr_day_u8 = I2C_Read(1);              // read Day and return Positive ACK
 5be:	81 e0       	ldi	r24, 0x01	; 1
 5c0:	0e 94 72 00 	call	0xe4	; 0xe4 <I2C_Read>
 5c4:	f8 01       	movw	r30, r16
 5c6:	80 83       	st	Z, r24
	*ptr_month_u8 = I2C_Read(1);            // read Month and return Positive ACK
 5c8:	81 e0       	ldi	r24, 0x01	; 1
 5ca:	0e 94 72 00 	call	0xe4	; 0xe4 <I2C_Read>
 5ce:	f7 01       	movw	r30, r14
 5d0:	80 83       	st	Z, r24
	*ptr_year_u8 = I2C_Read(0);             // read Year and return Negative/No ACK
 5d2:	80 e0       	ldi	r24, 0x00	; 0
 5d4:	0e 94 72 00 	call	0xe4	; 0xe4 <I2C_Read>
 5d8:	f6 01       	movw	r30, r12
 5da:	80 83       	st	Z, r24

	I2C_Stop();		                      // Stop I2C communication after reading the Date
 5dc:	0e 94 64 00 	call	0xc8	; 0xc8 <I2C_Stop>
}
 5e0:	1f 91       	pop	r17
 5e2:	0f 91       	pop	r16
 5e4:	ff 90       	pop	r15
 5e6:	ef 90       	pop	r14
 5e8:	df 90       	pop	r13
 5ea:	cf 90       	pop	r12
 5ec:	08 95       	ret

000005ee <RTC_GetTime>:

	Note: The time read from Ds1307 will be of BCD format, 
	      like 0x12,0x39,0x26 for 12hr,39min and 26sec.	
***************************************************************************************************/
void RTC_GetTime(uint8_t *ptr_hour_u8,uint8_t *ptr_min_u8,uint8_t *ptr_sec_u8)
{
 5ee:	cf 92       	push	r12
 5f0:	df 92       	push	r13
 5f2:	ef 92       	push	r14
 5f4:	ff 92       	push	r15
 5f6:	0f 93       	push	r16
 5f8:	1f 93       	push	r17
 5fa:	6c 01       	movw	r12, r24
 5fc:	7b 01       	movw	r14, r22
 5fe:	8a 01       	movw	r16, r20
	I2C_Start();                            // Start I2C communication
 600:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Start>

	I2C_Write(C_Ds1307WriteMode_U8);	    // connect to DS1307 by sending its ID on I2c Bus
 604:	80 ed       	ldi	r24, 0xD0	; 208
 606:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>
	I2C_Write(C_Ds1307SecondRegAddress_U8); // Request Sec RAM address at 00H
 60a:	80 e0       	ldi	r24, 0x00	; 0
 60c:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>

	I2C_Stop();			                    // Stop I2C communication after selecting Sec Register
 610:	0e 94 64 00 	call	0xc8	; 0xc8 <I2C_Stop>

	I2C_Start();		                    // Start I2C communication
 614:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Start>
	I2C_Write(C_Ds1307ReadMode_U8);	        // connect to DS1307(Read mode) by sending its ID
 618:	81 ed       	ldi	r24, 0xD1	; 209
 61a:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>

	*ptr_sec_u8 = I2C_Read(1);                // read second and return Positive ACK
 61e:	81 e0       	ldi	r24, 0x01	; 1
 620:	0e 94 72 00 	call	0xe4	; 0xe4 <I2C_Read>
 624:	f8 01       	movw	r30, r16
 626:	80 83       	st	Z, r24
	*ptr_min_u8 = I2C_Read(1); 	            // read minute and return Positive ACK
 628:	81 e0       	ldi	r24, 0x01	; 1
 62a:	0e 94 72 00 	call	0xe4	; 0xe4 <I2C_Read>
 62e:	f7 01       	movw	r30, r14
 630:	80 83       	st	Z, r24
	*ptr_hour_u8 = I2C_Read(0);               // read hour and return Negative/No ACK
 632:	80 e0       	ldi	r24, 0x00	; 0
 634:	0e 94 72 00 	call	0xe4	; 0xe4 <I2C_Read>
 638:	f6 01       	movw	r30, r12
 63a:	80 83       	st	Z, r24

	I2C_Stop();		                        // Stop I2C communication after reading the Time
 63c:	0e 94 64 00 	call	0xc8	; 0xc8 <I2C_Stop>
}
 640:	1f 91       	pop	r17
 642:	0f 91       	pop	r16
 644:	ff 90       	pop	r15
 646:	ef 90       	pop	r14
 648:	df 90       	pop	r13
 64a:	cf 90       	pop	r12
 64c:	08 95       	ret

0000064e <RTC_Init>:

 * description :This function is used to Initialize the Ds1307 RTC.
***************************************************************************************************/
void RTC_Init()
{
	I2C_Init();                             // Initialize the I2c module.
 64e:	0e 94 58 00 	call	0xb0	; 0xb0 <I2C_Init>
	I2C_Start();                            // Start I2C communication
 652:	0e 94 5e 00 	call	0xbc	; 0xbc <I2C_Start>

	I2C_Write(C_Ds1307WriteMode_U8);        // Connect to DS1307 by sending its ID on I2c Bus
 656:	80 ed       	ldi	r24, 0xD0	; 208
 658:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>
	I2C_Write(C_Ds1307ControlRegAddress_U8);// Select the Ds1307 ControlRegister to configure Ds1307
 65c:	87 e0       	ldi	r24, 0x07	; 7
 65e:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>

	I2C_Write(0x00);                        // Write 0x00 to Control register to disable SQW-Out
 662:	80 e0       	ldi	r24, 0x00	; 0
 664:	0e 94 6b 00 	call	0xd6	; 0xd6 <I2C_Write>

	I2C_Stop();                             // Stop I2C communication after initializing DS1307
 668:	0e 94 64 00 	call	0xc8	; 0xc8 <I2C_Stop>
}
 66c:	08 95       	ret

0000066e <main>:
#include "rtc.h" //User defined library which contains the RTC(ds1307) routines


/* start the main program */
void main() 
{
 66e:	2f 92       	push	r2
 670:	3f 92       	push	r3
 672:	4f 92       	push	r4
 674:	5f 92       	push	r5
 676:	6f 92       	push	r6
 678:	7f 92       	push	r7
 67a:	8f 92       	push	r8
 67c:	9f 92       	push	r9
 67e:	af 92       	push	r10
 680:	bf 92       	push	r11
 682:	cf 92       	push	r12
 684:	df 92       	push	r13
 686:	ef 92       	push	r14
 688:	ff 92       	push	r15
 68a:	0f 93       	push	r16
 68c:	1f 93       	push	r17
 68e:	df 93       	push	r29
 690:	cf 93       	push	r28
 692:	00 d0       	rcall	.+0      	; 0x694 <main+0x26>
 694:	00 d0       	rcall	.+0      	; 0x696 <main+0x28>
 696:	00 d0       	rcall	.+0      	; 0x698 <main+0x2a>
 698:	cd b7       	in	r28, 0x3d	; 61
 69a:	de b7       	in	r29, 0x3e	; 62
   unsigned char sec,min,hour,day,month,year;

  /* Initialize the lcd before displaying any thing on the lcd */
    LCD_Init(8,2,16);
 69c:	88 e0       	ldi	r24, 0x08	; 8
 69e:	62 e0       	ldi	r22, 0x02	; 2
 6a0:	40 e1       	ldi	r20, 0x10	; 16
 6a2:	0e 94 04 01 	call	0x208	; 0x208 <LCD_Init>

  /* Initialize the RTC(ds1307) before reading or writing time/date */
    RTC_Init();
 6a6:	0e 94 27 03 	call	0x64e	; 0x64e <RTC_Init>


  /*$$$$ Set the time and Date only once. Once the Time and Date is comment these lines
         and reflash the code. Else the time will be reset every time the controller is reset*/
    RTC_SetTime(0x10,0x40,0x00);  //  10:40:20 am
 6aa:	80 e1       	ldi	r24, 0x10	; 16
 6ac:	60 e4       	ldi	r22, 0x40	; 64
 6ae:	40 e0       	ldi	r20, 0x00	; 0
 6b0:	0e 94 aa 02 	call	0x554	; 0x554 <RTC_SetTime>
    RTC_SetDate(0x01,0x01,0x15);  //  1st Jan 2015
 6b4:	81 e0       	ldi	r24, 0x01	; 1
 6b6:	61 e0       	ldi	r22, 0x01	; 1
 6b8:	45 e1       	ldi	r20, 0x15	; 21
 6ba:	0e 94 8d 02 	call	0x51a	; 0x51a <RTC_SetDate>
   /* Display the Time and Date continuously */ 
   while(1)
    {
		LCD_GoToLine(1);
	   /* Read the Time from RTC(ds1307) */ 
        RTC_GetTime(&hour,&min,&sec);        		 
 6be:	53 e0       	ldi	r21, 0x03	; 3
 6c0:	25 2e       	mov	r2, r21
 6c2:	31 2c       	mov	r3, r1
 6c4:	2c 0e       	add	r2, r28
 6c6:	3d 1e       	adc	r3, r29
 6c8:	42 e0       	ldi	r20, 0x02	; 2
 6ca:	44 2e       	mov	r4, r20
 6cc:	51 2c       	mov	r5, r1
 6ce:	4c 0e       	add	r4, r28
 6d0:	5d 1e       	adc	r5, r29
 6d2:	3e 01       	movw	r6, r28
 6d4:	08 94       	sec
 6d6:	61 1c       	adc	r6, r1
 6d8:	71 1c       	adc	r7, r1
        LCD_Printf("time:%2x:%2x:%2x",hour,min,sec);
 6da:	35 e6       	ldi	r19, 0x65	; 101
 6dc:	83 2e       	mov	r8, r19
 6de:	30 e0       	ldi	r19, 0x00	; 0
 6e0:	93 2e       	mov	r9, r19

	
	    /* Read the Date from RTC(ds1307) */ 
        RTC_GetDate(&day,&month,&year);        
 6e2:	24 e0       	ldi	r18, 0x04	; 4
 6e4:	a2 2e       	mov	r10, r18
 6e6:	b1 2c       	mov	r11, r1
 6e8:	ac 0e       	add	r10, r28
 6ea:	bd 1e       	adc	r11, r29
 6ec:	95 e0       	ldi	r25, 0x05	; 5
 6ee:	c9 2e       	mov	r12, r25
 6f0:	d1 2c       	mov	r13, r1
 6f2:	cc 0e       	add	r12, r28
 6f4:	dd 1e       	adc	r13, r29
 6f6:	86 e0       	ldi	r24, 0x06	; 6
 6f8:	e8 2e       	mov	r14, r24
 6fa:	f1 2c       	mov	r15, r1
 6fc:	ec 0e       	add	r14, r28
 6fe:	fd 1e       	adc	r15, r29

		LCD_Printf("\nDate:%2x/%2x/%2x",day,month,year);
 700:	06 e7       	ldi	r16, 0x76	; 118
 702:	10 e0       	ldi	r17, 0x00	; 0


   /* Display the Time and Date continuously */ 
   while(1)
    {
		LCD_GoToLine(1);
 704:	81 e0       	ldi	r24, 0x01	; 1
 706:	0e 94 ed 00 	call	0x1da	; 0x1da <LCD_GoToLine>
	   /* Read the Time from RTC(ds1307) */ 
        RTC_GetTime(&hour,&min,&sec);        		 
 70a:	c1 01       	movw	r24, r2
 70c:	b2 01       	movw	r22, r4
 70e:	a3 01       	movw	r20, r6
 710:	0e 94 f7 02 	call	0x5ee	; 0x5ee <RTC_GetTime>
        LCD_Printf("time:%2x:%2x:%2x",hour,min,sec);
 714:	8d b7       	in	r24, 0x3d	; 61
 716:	9e b7       	in	r25, 0x3e	; 62
 718:	08 97       	sbiw	r24, 0x08	; 8
 71a:	0f b6       	in	r0, 0x3f	; 63
 71c:	f8 94       	cli
 71e:	9e bf       	out	0x3e, r25	; 62
 720:	0f be       	out	0x3f, r0	; 63
 722:	8d bf       	out	0x3d, r24	; 61
 724:	ed b7       	in	r30, 0x3d	; 61
 726:	fe b7       	in	r31, 0x3e	; 62
 728:	31 96       	adiw	r30, 0x01	; 1
 72a:	ad b7       	in	r26, 0x3d	; 61
 72c:	be b7       	in	r27, 0x3e	; 62
 72e:	12 96       	adiw	r26, 0x02	; 2
 730:	9c 92       	st	X, r9
 732:	8e 92       	st	-X, r8
 734:	11 97       	sbiw	r26, 0x01	; 1
 736:	8b 81       	ldd	r24, Y+3	; 0x03
 738:	82 83       	std	Z+2, r24	; 0x02
 73a:	13 82       	std	Z+3, r1	; 0x03
 73c:	8a 81       	ldd	r24, Y+2	; 0x02
 73e:	84 83       	std	Z+4, r24	; 0x04
 740:	15 82       	std	Z+5, r1	; 0x05
 742:	89 81       	ldd	r24, Y+1	; 0x01
 744:	86 83       	std	Z+6, r24	; 0x06
 746:	17 82       	std	Z+7, r1	; 0x07
 748:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <LCD_Printf>

	
	    /* Read the Date from RTC(ds1307) */ 
        RTC_GetDate(&day,&month,&year);        
 74c:	8d b7       	in	r24, 0x3d	; 61
 74e:	9e b7       	in	r25, 0x3e	; 62
 750:	08 96       	adiw	r24, 0x08	; 8
 752:	0f b6       	in	r0, 0x3f	; 63
 754:	f8 94       	cli
 756:	9e bf       	out	0x3e, r25	; 62
 758:	0f be       	out	0x3f, r0	; 63
 75a:	8d bf       	out	0x3d, r24	; 61
 75c:	c5 01       	movw	r24, r10
 75e:	b6 01       	movw	r22, r12
 760:	a7 01       	movw	r20, r14
 762:	0e 94 c7 02 	call	0x58e	; 0x58e <RTC_GetDate>

		LCD_Printf("\nDate:%2x/%2x/%2x",day,month,year);
 766:	ad b7       	in	r26, 0x3d	; 61
 768:	be b7       	in	r27, 0x3e	; 62
 76a:	18 97       	sbiw	r26, 0x08	; 8
 76c:	0f b6       	in	r0, 0x3f	; 63
 76e:	f8 94       	cli
 770:	be bf       	out	0x3e, r27	; 62
 772:	0f be       	out	0x3f, r0	; 63
 774:	ad bf       	out	0x3d, r26	; 61
 776:	ed b7       	in	r30, 0x3d	; 61
 778:	fe b7       	in	r31, 0x3e	; 62
 77a:	31 96       	adiw	r30, 0x01	; 1
 77c:	12 96       	adiw	r26, 0x02	; 2
 77e:	1c 93       	st	X, r17
 780:	0e 93       	st	-X, r16
 782:	11 97       	sbiw	r26, 0x01	; 1
 784:	8c 81       	ldd	r24, Y+4	; 0x04
 786:	82 83       	std	Z+2, r24	; 0x02
 788:	13 82       	std	Z+3, r1	; 0x03
 78a:	8d 81       	ldd	r24, Y+5	; 0x05
 78c:	84 83       	std	Z+4, r24	; 0x04
 78e:	15 82       	std	Z+5, r1	; 0x05
 790:	8e 81       	ldd	r24, Y+6	; 0x06
 792:	86 83       	std	Z+6, r24	; 0x06
 794:	17 82       	std	Z+7, r1	; 0x07
 796:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <LCD_Printf>
 79a:	8d b7       	in	r24, 0x3d	; 61
 79c:	9e b7       	in	r25, 0x3e	; 62
 79e:	08 96       	adiw	r24, 0x08	; 8
 7a0:	0f b6       	in	r0, 0x3f	; 63
 7a2:	f8 94       	cli
 7a4:	9e bf       	out	0x3e, r25	; 62
 7a6:	0f be       	out	0x3f, r0	; 63
 7a8:	8d bf       	out	0x3d, r24	; 61
 7aa:	ac cf       	rjmp	.-168    	; 0x704 <main+0x96>

000007ac <_exit>:
 7ac:	f8 94       	cli

000007ae <__stop_program>:
 7ae:	ff cf       	rjmp	.-2      	; 0x7ae <__stop_program>
