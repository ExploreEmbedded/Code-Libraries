
EEPROM_CharRdWr_LCD.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000658  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000022  00800060  00000658  000006ec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000005  00800082  00800082  0000070e  2**0
                  ALLOC
  3 .debug_aranges 00000080  00000000  00000000  0000070e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000197  00000000  00000000  0000078e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000aaf  00000000  00000000  00000925  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000040d  00000000  00000000  000013d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000a10  00000000  00000000  000017e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000150  00000000  00000000  000021f4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000502  00000000  00000000  00002344  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000548  00000000  00000000  00002846  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000090  00000000  00000000  00002d8e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 e5       	ldi	r30, 0x58	; 88
  68:	f6 e0       	ldi	r31, 0x06	; 6
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a2 38       	cpi	r26, 0x82	; 130
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a2 e8       	ldi	r26, 0x82	; 130
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a7 38       	cpi	r26, 0x87	; 135
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 67 00 	call	0xce	; 0xce <main>
  8a:	0c 94 2a 03 	jmp	0x654	; 0x654 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DELAY_sec>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  92:	44 e1       	ldi	r20, 0x14	; 20
  94:	51 e0       	ldi	r21, 0x01	; 1
  96:	09 c0       	rjmp	.+18     	; 0xaa <DELAY_sec+0x18>
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  98:	20 e1       	ldi	r18, 0x10	; 16
  9a:	37 e2       	ldi	r19, 0x27	; 39
  9c:	fa 01       	movw	r30, r20
  9e:	31 97       	sbiw	r30, 0x01	; 1
  a0:	f1 f7       	brne	.-4      	; 0x9e <DELAY_sec+0xc>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  a2:	21 50       	subi	r18, 0x01	; 1
  a4:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  a6:	d1 f7       	brne	.-12     	; 0x9c <DELAY_sec+0xa>
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
  a8:	01 97       	sbiw	r24, 0x01	; 1
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  aa:	00 97       	sbiw	r24, 0x00	; 0
  ac:	a9 f7       	brne	.-22     	; 0x98 <DELAY_sec+0x6>
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
		}
  }
  ae:	08 95       	ret

000000b0 <EEPROM_WriteByte>:
 * description: This function is used to write the data at specified EEPROM_address..

 **************************************************************************************************/
void EEPROM_WriteByte(uint16_t var_eepromAddress_u16, uint8_t var_eepromData_u8)
{
	while(util_IsBitSet(EECR,EEWE)); // Wait for completion of previous write.
  b0:	e1 99       	sbic	0x1c, 1	; 28
  b2:	fe cf       	rjmp	.-4      	; 0xb0 <EEPROM_WriteByte>
	                                 // EEWE will be cleared by hardware once Eeprom write is completed.

	EEAR = var_eepromAddress_u16;  //Load the eeprom address and data
  b4:	9f bb       	out	0x1f, r25	; 31
  b6:	8e bb       	out	0x1e, r24	; 30
	EEDR = var_eepromData_u8;
  b8:	6d bb       	out	0x1d, r22	; 29

	util_BitSet(EECR,EEMWE);    // Eeprom Master Write Enable
  ba:	e2 9a       	sbi	0x1c, 2	; 28
	util_BitSet(EECR,EEWE);     // Start eeprom write by setting EEWE
  bc:	e1 9a       	sbi	0x1c, 1	; 28
}
  be:	08 95       	ret

000000c0 <EEPROM_ReadByte>:

 * description: This function is used to read the data from specified EEPROM_address.        
 ***************************************************************************************************/
uint8_t EEPROM_ReadByte(uint16_t var_eepromAddress_u16)
{
	while(util_IsBitSet(EECR,EEWE));  //Wait for completion of previous write if any.
  c0:	e1 99       	sbic	0x1c, 1	; 28
  c2:	fe cf       	rjmp	.-4      	; 0xc0 <EEPROM_ReadByte>

	EEAR = var_eepromAddress_u16;    //Load the address from where the data needs to be read.
  c4:	9f bb       	out	0x1f, r25	; 31
  c6:	8e bb       	out	0x1e, r24	; 30
	util_BitSet(EECR,EERE);   // start eeprom read by setting EERE
  c8:	e0 9a       	sbi	0x1c, 0	; 28

	return EEDR;             // Return data from data register
  ca:	8d b3       	in	r24, 0x1d	; 29
}
  cc:	08 95       	ret

000000ce <main>:
void main() 
{
   unsigned char eeprom_address=0x00, write_char = 'X', read_char;

  /* Initialize the lcd before displaying any thing on the lcd */
    LCD_Init(8,2,16);												  
  ce:	88 e0       	ldi	r24, 0x08	; 8
  d0:	62 e0       	ldi	r22, 0x02	; 2
  d2:	40 e1       	ldi	r20, 0x10	; 16
  d4:	0e 94 10 01 	call	0x220	; 0x220 <LCD_Init>
 
   while(1)
    {					
	   	   LCD_GoToLine(1);							// Move the cursor to first line
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <LCD_GoToLine>
           LCD_DisplayString("Eeprom Write: ");         //Display the message on first line
  de:	80 e6       	ldi	r24, 0x60	; 96
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	0e 94 0f 02 	call	0x41e	; 0x41e <LCD_DisplayString>
		   LCD_DisplayChar(write_char);			        //Display the char to be written 
  e6:	88 e5       	ldi	r24, 0x58	; 88
  e8:	0e 94 70 01 	call	0x2e0	; 0x2e0 <LCD_DisplayChar>
		   EEPROM_WriteByte(eeprom_address,write_char);	// Write the data at memoryLocation	0x00
  ec:	80 e0       	ldi	r24, 0x00	; 0
  ee:	90 e0       	ldi	r25, 0x00	; 0
  f0:	68 e5       	ldi	r22, 0x58	; 88
  f2:	0e 94 58 00 	call	0xb0	; 0xb0 <EEPROM_WriteByte>

		   LCD_GoToLine(2);							// Move the cursor to Second line
  f6:	82 e0       	ldi	r24, 0x02	; 2
  f8:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <LCD_GoToLine>
		   LCD_DisplayString("Eeprom Read: ");          //Display the message on first line
  fc:	8f e6       	ldi	r24, 0x6F	; 111
  fe:	90 e0       	ldi	r25, 0x00	; 0
 100:	0e 94 0f 02 	call	0x41e	; 0x41e <LCD_DisplayString>
		   read_char = EEPROM_ReadByte(eeprom_address);	// Read the data from memoryLocation 0x00
 104:	80 e0       	ldi	r24, 0x00	; 0
 106:	90 e0       	ldi	r25, 0x00	; 0
 108:	0e 94 60 00 	call	0xc0	; 0xc0 <EEPROM_ReadByte>
		   LCD_DisplayChar(read_char);			        //Display the read data 
 10c:	0e 94 70 01 	call	0x2e0	; 0x2e0 <LCD_DisplayChar>
 110:	e3 cf       	rjmp	.-58     	; 0xd8 <main+0xa>

00000112 <lcd_BusyCheck>:
static void lcd_BusyCheck()
{
	uint8_t busyflag;
#ifdef LCD_RW       //Perform Busy check if LCD_RW pin is used

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
 112:	a7 98       	cbi	0x14, 7	; 20
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 114:	95 98       	cbi	0x12, 5	; 18
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
 116:	96 9a       	sbi	0x12, 6	; 18
		M_LcdSetBit(LCD_EN); 
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 118:	30 91 86 00 	lds	r19, 0x0086
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 11c:	94 e2       	ldi	r25, 0x24	; 36
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
	do
	{

		M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
 11e:	97 98       	cbi	0x12, 7	; 18
 120:	89 2f       	mov	r24, r25
 122:	8a 95       	dec	r24
 124:	f1 f7       	brne	.-4      	; 0x122 <lcd_BusyCheck+0x10>
		DELAY_us(10);	
		M_LcdSetBit(LCD_EN); 
 126:	97 9a       	sbi	0x12, 7	; 18
 128:	89 2f       	mov	r24, r25
 12a:	8a 95       	dec	r24
 12c:	f1 f7       	brne	.-4      	; 0x12a <lcd_BusyCheck+0x18>
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
 12e:	23 b3       	in	r18, 0x13	; 19


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
 130:	34 30       	cpi	r19, 0x04	; 4
 132:	41 f4       	brne	.+16     	; 0x144 <lcd_BusyCheck+0x32>
		{
			/* Perform extra dummy read for 4-bit */ 	   	
			M_LcdClearBit(LCD_EN);
 134:	97 98       	cbi	0x12, 7	; 18
 136:	89 2f       	mov	r24, r25
 138:	8a 95       	dec	r24
 13a:	f1 f7       	brne	.-4      	; 0x138 <lcd_BusyCheck+0x26>
			DELAY_us(10);
			M_LcdSetBit(LCD_EN); 
 13c:	97 9a       	sbi	0x12, 7	; 18
 13e:	89 2f       	mov	r24, r25
 140:	8a 95       	dec	r24
 142:	f1 f7       	brne	.-4      	; 0x140 <lcd_BusyCheck+0x2e>
			DELAY_us(10);
		}	
	}while(busyflag);
 144:	27 fd       	sbrc	r18, 7
 146:	eb cf       	rjmp	.-42     	; 0x11e <lcd_BusyCheck+0xc>

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
 148:	a7 9a       	sbi	0x14, 7	; 20
#else
	/* Busy flag cannot be read as LCD_RW is not available hence Extra delay of 1ms is added 
	  to ensure the LCD completes previous operation and ready to receive new commands/data */
	DELAY_ms(1);  
#endif
}
 14a:	08 95       	ret

0000014c <lcd_SendNibble>:

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 *************************************************************************************************/
static void lcd_SendNibble(uint8_t var)
{
	util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
 14c:	98 2f       	mov	r25, r24
 14e:	84 ff       	sbrs	r24, 4
 150:	02 c0       	rjmp	.+4      	; 0x156 <lcd_SendNibble+0xa>
 152:	ac 9a       	sbi	0x15, 4	; 21
 154:	01 c0       	rjmp	.+2      	; 0x158 <lcd_SendNibble+0xc>
 156:	ac 98       	cbi	0x15, 4	; 21
 158:	25 b3       	in	r18, 0x15	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
 15a:	95 ff       	sbrs	r25, 5
 15c:	02 c0       	rjmp	.+4      	; 0x162 <lcd_SendNibble+0x16>
 15e:	ad 9a       	sbi	0x15, 5	; 21
 160:	01 c0       	rjmp	.+2      	; 0x164 <lcd_SendNibble+0x18>
 162:	ad 98       	cbi	0x15, 5	; 21
 164:	25 b3       	in	r18, 0x15	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
 166:	96 ff       	sbrs	r25, 6
 168:	02 c0       	rjmp	.+4      	; 0x16e <lcd_SendNibble+0x22>
 16a:	ae 9a       	sbi	0x15, 6	; 21
 16c:	01 c0       	rjmp	.+2      	; 0x170 <lcd_SendNibble+0x24>
 16e:	ae 98       	cbi	0x15, 6	; 21
 170:	95 b3       	in	r25, 0x15	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
 172:	87 ff       	sbrs	r24, 7
 174:	02 c0       	rjmp	.+4      	; 0x17a <lcd_SendNibble+0x2e>
 176:	af 9a       	sbi	0x15, 7	; 21
 178:	01 c0       	rjmp	.+2      	; 0x17c <lcd_SendNibble+0x30>
 17a:	af 98       	cbi	0x15, 7	; 21
 17c:	85 b3       	in	r24, 0x15	; 21
 17e:	08 95       	ret

00000180 <lcd_SendCmdSignals>:

 * description : This functions generates the signals for sending the var_lcdCmd_u8 to LCD
 *************************************************************************************************/
static void lcd_SendCmdSignals()
{
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 180:	95 98       	cbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
 182:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
 184:	97 9a       	sbi	0x12, 7	; 18
 186:	84 e2       	ldi	r24, 0x24	; 36
 188:	8a 95       	dec	r24
 18a:	f1 f7       	brne	.-4      	; 0x188 <lcd_SendCmdSignals+0x8>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 18c:	97 98       	cbi	0x12, 7	; 18
}
 18e:	08 95       	ret

00000190 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.				
				The behaviour is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
{
 190:	1f 93       	push	r17
 192:	18 2f       	mov	r17, r24
	lcd_BusyCheck();
 194:	0e 94 89 00 	call	0x112	; 0x112 <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 198:	80 91 86 00 	lds	r24, 0x0086
 19c:	88 30       	cpi	r24, 0x08	; 8
 19e:	11 f4       	brne	.+4      	; 0x1a4 <LCD_CmdWrite+0x14>
	{

		M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
 1a0:	15 bb       	out	0x15, r17	; 21
 1a2:	0c c0       	rjmp	.+24     	; 0x1bc <LCD_CmdWrite+0x2c>
		lcd_SendCmdSignals();  // Signals for command write operation
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 1a4:	84 30       	cpi	r24, 0x04	; 4
 1a6:	61 f4       	brne	.+24     	; 0x1c0 <LCD_CmdWrite+0x30>
	{
		lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
 1a8:	81 2f       	mov	r24, r17
 1aa:	0e 94 a6 00 	call	0x14c	; 0x14c <lcd_SendNibble>
		lcd_SendCmdSignals(); // Signals for command write operation
 1ae:	0e 94 c0 00 	call	0x180	; 0x180 <lcd_SendCmdSignals>

		lcd_SendNibble(var_lcdCmd_u8 << 4);
 1b2:	81 2f       	mov	r24, r17
 1b4:	82 95       	swap	r24
 1b6:	80 7f       	andi	r24, 0xF0	; 240
 1b8:	0e 94 a6 00 	call	0x14c	; 0x14c <lcd_SendNibble>
		lcd_SendCmdSignals();
 1bc:	0e 94 c0 00 	call	0x180	; 0x180 <lcd_SendCmdSignals>
	}
}
 1c0:	1f 91       	pop	r17
 1c2:	08 95       	ret

000001c4 <LCD_GoToNextLine>:
 ***************************************************************************************************/
void  LCD_GoToNextLine()
{
	/*Increment the current line number.
	  In case it exceeds the limit, rool it back to first line */
	VAR_LcdTrackLineNum_U8++;
 1c4:	80 91 83 00 	lds	r24, 0x0083
 1c8:	8f 5f       	subi	r24, 0xFF	; 255
 1ca:	80 93 83 00 	sts	0x0083, r24
	VAR_LcdTrackCursorPos_U8 = 0x00;
 1ce:	10 92 82 00 	sts	0x0082, r1
	if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 1d2:	90 91 84 00 	lds	r25, 0x0084
 1d6:	98 17       	cp	r25, r24
 1d8:	18 f4       	brcc	.+6      	; 0x1e0 <LCD_GoToNextLine+0x1c>
		VAR_LcdTrackLineNum_U8 = 0x01;
 1da:	81 e0       	ldi	r24, 0x01	; 1
 1dc:	80 93 83 00 	sts	0x0083, r24
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
 1e0:	e0 91 83 00 	lds	r30, 0x0083
 1e4:	f0 e0       	ldi	r31, 0x00	; 0
 1e6:	e3 58       	subi	r30, 0x83	; 131
 1e8:	ff 4f       	sbci	r31, 0xFF	; 255
 1ea:	80 81       	ld	r24, Z
 1ec:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_CmdWrite>
}
 1f0:	08 95       	ret

000001f2 <LCD_GoToLine>:
           mENUM_LcdLineTwo,
           mENUM_LcdLineThree,
           mENUM_LcdLineFour,
 ***************************************************************************************************/
void LCD_GoToLine(uint8_t var_lineNumber_u8)
{
 1f2:	e8 2f       	mov	r30, r24
	if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
 1f4:	80 91 84 00 	lds	r24, 0x0084
 1f8:	8e 17       	cp	r24, r30
 1fa:	50 f0       	brcs	.+20     	; 0x210 <LCD_GoToLine+0x1e>
	{
		/* If the line number is within range then
	       Move the Cursor to beginning of the specified line */
		VAR_LcdTrackCursorPos_U8 = 0x00;
 1fc:	10 92 82 00 	sts	0x0082, r1
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 200:	e0 93 83 00 	sts	0x0083, r30
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
 204:	f0 e0       	ldi	r31, 0x00	; 0
 206:	e3 58       	subi	r30, 0x83	; 131
 208:	ff 4f       	sbci	r31, 0xFF	; 255
 20a:	80 81       	ld	r24, Z
 20c:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_CmdWrite>
 210:	08 95       	ret

00000212 <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ***************************************************************************************************/
void LCD_Clear()
{
	LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
 212:	81 e0       	ldi	r24, 0x01	; 1
 214:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_CmdWrite>
	LCD_GoToLine(mENUM_LcdLineOne);
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <LCD_GoToLine>
}
 21e:	08 95       	ret

00000220 <LCD_Init>:

 * description  :This function is used to initialize the lcd.
                 *It initializes the LCD for selected mode(4/8-bit) and Type(16x2/16x1 etc)
**************************************************************************************************/
void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
{
 220:	0f 93       	push	r16
 222:	1f 93       	push	r17
 224:	58 2f       	mov	r21, r24


	M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
 226:	8f ef       	ldi	r24, 0xFF	; 255
 228:	84 bb       	out	0x14, r24	; 20
	M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
 22a:	81 bb       	out	0x11, r24	; 17
	STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
 22c:	50 93 86 00 	sts	0x0086, r21
	STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
 230:	40 93 85 00 	sts	0x0085, r20
	STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
 234:	60 93 84 00 	sts	0x0084, r22
	if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
 238:	63 30       	cpi	r22, 0x03	; 3
 23a:	40 f0       	brcs	.+16     	; 0x24c <LCD_Init+0x2c>
	{
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
 23c:	84 2f       	mov	r24, r20
 23e:	8f 70       	andi	r24, 0x0F	; 15
 240:	80 57       	subi	r24, 0x70	; 112
 242:	80 93 80 00 	sts	0x0080, r24
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
 246:	80 5c       	subi	r24, 0xC0	; 192
 248:	80 93 81 00 	sts	0x0081, r24
 24c:	88 ee       	ldi	r24, 0xE8	; 232
 24e:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 250:	24 e1       	ldi	r18, 0x14	; 20
 252:	31 e0       	ldi	r19, 0x01	; 1
 254:	f9 01       	movw	r30, r18
 256:	31 97       	sbiw	r30, 0x01	; 1
 258:	f1 f7       	brne	.-4      	; 0x256 <LCD_Init+0x36>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 25a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 25c:	d9 f7       	brne	.-10     	; 0x254 <LCD_Init+0x34>
	}

	DELAY_ms(100);

	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 25e:	58 30       	cpi	r21, 0x08	; 8
 260:	11 f4       	brne	.+4      	; 0x266 <LCD_Init+0x46>
	{
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 262:	88 e3       	ldi	r24, 0x38	; 56
 264:	2b c0       	rjmp	.+86     	; 0x2bc <LCD_Init+0x9c>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 266:	54 30       	cpi	r21, 0x04	; 4
 268:	59 f5       	brne	.+86     	; 0x2c0 <LCD_Init+0xa0>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset()
{
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendNibble(0x30);
 26a:	80 e3       	ldi	r24, 0x30	; 48
 26c:	0e 94 a6 00 	call	0x14c	; 0x14c <lcd_SendNibble>
	lcd_SendCmdSignals();
 270:	0e 94 c0 00 	call	0x180	; 0x180 <lcd_SendCmdSignals>
 274:	88 ee       	ldi	r24, 0xE8	; 232
 276:	93 e0       	ldi	r25, 0x03	; 3
 278:	24 e1       	ldi	r18, 0x14	; 20
 27a:	31 e0       	ldi	r19, 0x01	; 1
 27c:	f9 01       	movw	r30, r18
 27e:	31 97       	sbiw	r30, 0x01	; 1
 280:	f1 f7       	brne	.-4      	; 0x27e <LCD_Init+0x5e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 282:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 284:	d9 f7       	brne	.-10     	; 0x27c <LCD_Init+0x5c>
	DELAY_ms(100);
	lcd_SendNibble(0x30);
 286:	80 e3       	ldi	r24, 0x30	; 48
 288:	0e 94 a6 00 	call	0x14c	; 0x14c <lcd_SendNibble>
	lcd_SendCmdSignals();
 28c:	0e 94 c0 00 	call	0x180	; 0x180 <lcd_SendCmdSignals>
 290:	08 e2       	ldi	r16, 0x28	; 40
 292:	12 e0       	ldi	r17, 0x02	; 2
 294:	c8 01       	movw	r24, r16
 296:	01 97       	sbiw	r24, 0x01	; 1
 298:	f1 f7       	brne	.-4      	; 0x296 <LCD_Init+0x76>
	DELAY_us(200);
	lcd_SendNibble(0x30);
 29a:	80 e3       	ldi	r24, 0x30	; 48
 29c:	0e 94 a6 00 	call	0x14c	; 0x14c <lcd_SendNibble>
	lcd_SendCmdSignals();
 2a0:	0e 94 c0 00 	call	0x180	; 0x180 <lcd_SendCmdSignals>
 2a4:	c8 01       	movw	r24, r16
 2a6:	01 97       	sbiw	r24, 0x01	; 1
 2a8:	f1 f7       	brne	.-4      	; 0x2a6 <LCD_Init+0x86>
	DELAY_us(200);
	lcd_SendNibble(0x20);
 2aa:	80 e2       	ldi	r24, 0x20	; 32
 2ac:	0e 94 a6 00 	call	0x14c	; 0x14c <lcd_SendNibble>
	lcd_SendCmdSignals();
 2b0:	0e 94 c0 00 	call	0x180	; 0x180 <lcd_SendCmdSignals>
 2b4:	c8 01       	movw	r24, r16
 2b6:	01 97       	sbiw	r24, 0x01	; 1
 2b8:	f1 f7       	brne	.-4      	; 0x2b6 <LCD_Init+0x96>
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
	{
		lcd_Reset();
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 2ba:	88 e2       	ldi	r24, 0x28	; 40
 2bc:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);	 // Display ON cursor ON
 2c0:	8e e0       	ldi	r24, 0x0E	; 14
 2c2:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_CmdWrite>
	LCD_Clear();	                         // Clear the LCD and go to First line First Position
 2c6:	0e 94 09 01 	call	0x212	; 0x212 <LCD_Clear>
}
 2ca:	1f 91       	pop	r17
 2cc:	0f 91       	pop	r16
 2ce:	08 95       	ret

000002d0 <lcd_SendDataSignals>:

 * description : This functions generates the signals for sending the Data to LCD
 *************************************************************************************************/
static void lcd_SendDataSignals()
{
	M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
 2d0:	95 9a       	sbi	0x12, 5	; 18
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
 2d2:	96 98       	cbi	0x12, 6	; 18
#endif
	M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
 2d4:	97 9a       	sbi	0x12, 7	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 2d6:	84 e2       	ldi	r24, 0x24	; 36
 2d8:	8a 95       	dec	r24
 2da:	f1 f7       	brne	.-4      	; 0x2d8 <lcd_SendDataSignals+0x8>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 2dc:	97 98       	cbi	0x12, 7	; 18
}
 2de:	08 95       	ret

000002e0 <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
void LCD_DisplayChar(char var_lcdData_u8)
{
 2e0:	1f 93       	push	r17
 2e2:	18 2f       	mov	r17, r24
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
 2e4:	90 91 82 00 	lds	r25, 0x0082
 2e8:	80 91 85 00 	lds	r24, 0x0085
 2ec:	98 17       	cp	r25, r24
 2ee:	10 f4       	brcc	.+4      	; 0x2f4 <LCD_DisplayChar+0x14>
 2f0:	1a 30       	cpi	r17, 0x0A	; 10
 2f2:	21 f4       	brne	.+8      	; 0x2fc <LCD_DisplayChar+0x1c>
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 2f4:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <LCD_GoToNextLine>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 2f8:	1a 30       	cpi	r17, 0x0A	; 10
 2fa:	d9 f0       	breq	.+54     	; 0x332 <LCD_DisplayChar+0x52>

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void lcd_DataWrite( uint8_t dat)
{
	lcd_BusyCheck();
 2fc:	0e 94 89 00 	call	0x112	; 0x112 <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 300:	80 91 86 00 	lds	r24, 0x0086
 304:	88 30       	cpi	r24, 0x08	; 8
 306:	11 f4       	brne	.+4      	; 0x30c <LCD_DisplayChar+0x2c>
	{
		M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
 308:	15 bb       	out	0x15, r17	; 21
 30a:	0c c0       	rjmp	.+24     	; 0x324 <LCD_DisplayChar+0x44>
		lcd_SendDataSignals();  // Signals for data write operation
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 30c:	84 30       	cpi	r24, 0x04	; 4
 30e:	61 f4       	brne	.+24     	; 0x328 <LCD_DisplayChar+0x48>
	{
		lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
 310:	81 2f       	mov	r24, r17
 312:	0e 94 a6 00 	call	0x14c	; 0x14c <lcd_SendNibble>
		lcd_SendDataSignals();  // Signals for data write operation
 316:	0e 94 68 01 	call	0x2d0	; 0x2d0 <lcd_SendDataSignals>

		lcd_SendNibble(dat << 4);
 31a:	81 2f       	mov	r24, r17
 31c:	82 95       	swap	r24
 31e:	80 7f       	andi	r24, 0xF0	; 240
 320:	0e 94 a6 00 	call	0x14c	; 0x14c <lcd_SendNibble>
		lcd_SendDataSignals();
 324:	0e 94 68 01 	call	0x2d0	; 0x2d0 <lcd_SendDataSignals>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
 328:	80 91 82 00 	lds	r24, 0x0082
 32c:	8f 5f       	subi	r24, 0xFF	; 255
 32e:	80 93 82 00 	sts	0x0082, r24
	}
}
 332:	1f 91       	pop	r17
 334:	08 95       	ret

00000336 <LCD_DisplayDecimalNumber>:
				2.(12345,6) then 6-digits ie. 012345 will be displayed
				3.(12345,C_DisplayDefaultDigits_U8) then 12345 will be displayed.
 ***************************************************************************************************/
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
 336:	6f 92       	push	r6
 338:	7f 92       	push	r7
 33a:	9f 92       	push	r9
 33c:	af 92       	push	r10
 33e:	bf 92       	push	r11
 340:	cf 92       	push	r12
 342:	df 92       	push	r13
 344:	ef 92       	push	r14
 346:	ff 92       	push	r15
 348:	0f 93       	push	r16
 34a:	df 93       	push	r29
 34c:	cf 93       	push	r28
 34e:	cd b7       	in	r28, 0x3d	; 61
 350:	de b7       	in	r29, 0x3e	; 62
 352:	2a 97       	sbiw	r28, 0x0a	; 10
 354:	0f b6       	in	r0, 0x3f	; 63
 356:	f8 94       	cli
 358:	de bf       	out	0x3e, r29	; 62
 35a:	0f be       	out	0x3f, r0	; 63
 35c:	cd bf       	out	0x3d, r28	; 61
 35e:	6b 01       	movw	r12, r22
 360:	7c 01       	movw	r14, r24
 362:	94 2e       	mov	r9, r20
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
 364:	61 15       	cp	r22, r1
 366:	71 05       	cpc	r23, r1
 368:	81 05       	cpc	r24, r1
 36a:	91 05       	cpc	r25, r1
 36c:	31 f0       	breq	.+12     	; 0x37a <LCD_DisplayDecimalNumber+0x44>
 36e:	00 e0       	ldi	r16, 0x00	; 0
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
 370:	3e 01       	movw	r6, r28
 372:	08 94       	sec
 374:	61 1c       	adc	r6, r1
 376:	71 1c       	adc	r7, r1
 378:	32 c0       	rjmp	.+100    	; 0x3de <LCD_DisplayDecimalNumber+0xa8>
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
 37a:	fe 01       	movw	r30, r28
 37c:	31 96       	adiw	r30, 0x01	; 1
 37e:	00 e0       	ldi	r16, 0x00	; 0
 380:	02 c0       	rjmp	.+4      	; 0x386 <LCD_DisplayDecimalNumber+0x50>
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
 382:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 384:	0f 5f       	subi	r16, 0xFF	; 255
 386:	09 15       	cp	r16, r9
 388:	a8 f5       	brcc	.+106    	; 0x3f4 <LCD_DisplayDecimalNumber+0xbe>
 38a:	0a 30       	cpi	r16, 0x0A	; 10
 38c:	d1 f7       	brne	.-12     	; 0x382 <LCD_DisplayDecimalNumber+0x4c>
 38e:	32 c0       	rjmp	.+100    	; 0x3f4 <LCD_DisplayDecimalNumber+0xbe>
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_DecNumber_u32!=0)
 390:	c1 14       	cp	r12, r1
 392:	d1 04       	cpc	r13, r1
 394:	e1 04       	cpc	r14, r1
 396:	f1 04       	cpc	r15, r1
 398:	d1 f0       	breq	.+52     	; 0x3ce <LCD_DisplayDecimalNumber+0x98>
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 39a:	53 01       	movw	r10, r6
 39c:	a0 0e       	add	r10, r16
 39e:	b1 1c       	adc	r11, r1
 3a0:	c7 01       	movw	r24, r14
 3a2:	b6 01       	movw	r22, r12
 3a4:	2a e0       	ldi	r18, 0x0A	; 10
 3a6:	30 e0       	ldi	r19, 0x00	; 0
 3a8:	40 e0       	ldi	r20, 0x00	; 0
 3aa:	50 e0       	ldi	r21, 0x00	; 0
 3ac:	0e 94 08 03 	call	0x610	; 0x610 <__udivmodsi4>
 3b0:	f5 01       	movw	r30, r10
 3b2:	60 83       	st	Z, r22
				var_DecNumber_u32=var_DecNumber_u32/10;
 3b4:	c7 01       	movw	r24, r14
 3b6:	b6 01       	movw	r22, r12
 3b8:	2a e0       	ldi	r18, 0x0A	; 10
 3ba:	30 e0       	ldi	r19, 0x00	; 0
 3bc:	40 e0       	ldi	r20, 0x00	; 0
 3be:	50 e0       	ldi	r21, 0x00	; 0
 3c0:	0e 94 08 03 	call	0x610	; 0x610 <__udivmodsi4>
 3c4:	c9 01       	movw	r24, r18
 3c6:	da 01       	movw	r26, r20
 3c8:	6c 01       	movw	r12, r24
 3ca:	7d 01       	movw	r14, r26
 3cc:	07 c0       	rjmp	.+14     	; 0x3dc <LCD_DisplayDecimalNumber+0xa6>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 3ce:	fa e0       	ldi	r31, 0x0A	; 10
 3d0:	f9 15       	cp	r31, r9
 3d2:	80 f0       	brcs	.+32     	; 0x3f4 <LCD_DisplayDecimalNumber+0xbe>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
 3d4:	f3 01       	movw	r30, r6
 3d6:	e0 0f       	add	r30, r16
 3d8:	f1 1d       	adc	r31, r1
 3da:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 3dc:	0f 5f       	subi	r16, 0xFF	; 255
 3de:	09 15       	cp	r16, r9
 3e0:	b8 f2       	brcs	.-82     	; 0x390 <LCD_DisplayDecimalNumber+0x5a>
 3e2:	08 c0       	rjmp	.+16     	; 0x3f4 <LCD_DisplayDecimalNumber+0xbe>


	while(i)
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
 3e4:	fe 01       	movw	r30, r28
 3e6:	e0 0f       	add	r30, r16
 3e8:	f1 1d       	adc	r31, r1
 3ea:	80 81       	ld	r24, Z
 3ec:	80 5d       	subi	r24, 0xD0	; 208
 3ee:	0e 94 70 01 	call	0x2e0	; 0x2e0 <LCD_DisplayChar>
		i--;
 3f2:	01 50       	subi	r16, 0x01	; 1
			}
		}
	}


	while(i)
 3f4:	00 23       	and	r16, r16
 3f6:	b1 f7       	brne	.-20     	; 0x3e4 <LCD_DisplayDecimalNumber+0xae>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
		i--;
	}
}
 3f8:	2a 96       	adiw	r28, 0x0a	; 10
 3fa:	0f b6       	in	r0, 0x3f	; 63
 3fc:	f8 94       	cli
 3fe:	de bf       	out	0x3e, r29	; 62
 400:	0f be       	out	0x3f, r0	; 63
 402:	cd bf       	out	0x3d, r28	; 61
 404:	cf 91       	pop	r28
 406:	df 91       	pop	r29
 408:	0f 91       	pop	r16
 40a:	ff 90       	pop	r15
 40c:	ef 90       	pop	r14
 40e:	df 90       	pop	r13
 410:	cf 90       	pop	r12
 412:	bf 90       	pop	r11
 414:	af 90       	pop	r10
 416:	9f 90       	pop	r9
 418:	7f 90       	pop	r7
 41a:	6f 90       	pop	r6
 41c:	08 95       	ret

0000041e <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
 41e:	cf 93       	push	r28
 420:	df 93       	push	r29
 422:	ec 01       	movw	r28, r24
 424:	03 c0       	rjmp	.+6      	; 0x42c <LCD_DisplayString+0xe>
	while((*ptr_stringPointer_u8)!=0)
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
 426:	21 96       	adiw	r28, 0x01	; 1
 428:	0e 94 70 01 	call	0x2e0	; 0x2e0 <LCD_DisplayChar>

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
	while((*ptr_stringPointer_u8)!=0)
 42c:	88 81       	ld	r24, Y
 42e:	88 23       	and	r24, r24
 430:	d1 f7       	brne	.-12     	; 0x426 <LCD_DisplayString+0x8>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
 432:	df 91       	pop	r29
 434:	cf 91       	pop	r28
 436:	08 95       	ret

00000438 <LCD_Printf>:
	     %12b: will display the 12-LSB of the number
		 %d: Will display the exact digits of the number
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
 438:	8f 92       	push	r8
 43a:	9f 92       	push	r9
 43c:	af 92       	push	r10
 43e:	bf 92       	push	r11
 440:	cf 92       	push	r12
 442:	df 92       	push	r13
 444:	ef 92       	push	r14
 446:	ff 92       	push	r15
 448:	0f 93       	push	r16
 44a:	1f 93       	push	r17
 44c:	df 93       	push	r29
 44e:	cf 93       	push	r28
 450:	cd b7       	in	r28, 0x3d	; 61
 452:	de b7       	in	r29, 0x3e	; 62
 454:	31 e1       	ldi	r19, 0x11	; 17
 456:	e3 2e       	mov	r14, r19
 458:	f1 2c       	mov	r15, r1
 45a:	ec 0e       	add	r14, r28
 45c:	fd 1e       	adc	r15, r29
 45e:	8f 85       	ldd	r24, Y+15	; 0x0f
 460:	98 89       	ldd	r25, Y+16	; 0x10
 462:	9c 01       	movw	r18, r24
 464:	59 01       	movw	r10, r18
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 466:	2a e0       	ldi	r18, 0x0A	; 10
 468:	c2 2e       	mov	r12, r18
 46a:	c0 c0       	rjmp	.+384    	; 0x5ec <__stack+0x18d>
	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
	{

		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
 46c:	85 32       	cpi	r24, 0x25	; 37
 46e:	09 f0       	breq	.+2      	; 0x472 <__stack+0x13>
 470:	b8 c0       	rjmp	.+368    	; 0x5e2 <__stack+0x183>
		{
		    ptr++;
 472:	08 94       	sec
 474:	a1 1c       	adc	r10, r1
 476:	b1 1c       	adc	r11, r1
		    ch = *ptr;
 478:	f5 01       	movw	r30, r10
 47a:	90 81       	ld	r25, Z
		   if((ch>=0x30) && (ch<=0x39))
 47c:	89 2f       	mov	r24, r25
 47e:	80 53       	subi	r24, 0x30	; 48
 480:	8a 30       	cpi	r24, 0x0A	; 10
 482:	18 f0       	brcs	.+6      	; 0x48a <__stack+0x2b>
 484:	dd 24       	eor	r13, r13
 486:	da 94       	dec	r13
 488:	0f c0       	rjmp	.+30     	; 0x4a8 <__stack+0x49>
 48a:	dd 24       	eor	r13, r13
 48c:	09 c0       	rjmp	.+18     	; 0x4a0 <__stack+0x41>
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 48e:	dc 9c       	mul	r13, r12
 490:	d0 2c       	mov	r13, r0
 492:	11 24       	eor	r1, r1
 494:	d8 0e       	add	r13, r24
				   ptr++;
 496:	08 94       	sec
 498:	a1 1c       	adc	r10, r1
 49a:	b1 1c       	adc	r11, r1
				   ch = *ptr;
 49c:	f5 01       	movw	r30, r10
 49e:	90 81       	ld	r25, Z
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
 4a0:	89 2f       	mov	r24, r25
 4a2:	80 53       	subi	r24, 0x30	; 48
 4a4:	8a 30       	cpi	r24, 0x0A	; 10
 4a6:	98 f3       	brcs	.-26     	; 0x48e <__stack+0x2f>
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
 4a8:	98 35       	cpi	r25, 0x58	; 88
 4aa:	09 f4       	brne	.+2      	; 0x4ae <__stack+0x4f>
 4ac:	85 c0       	rjmp	.+266    	; 0x5b8 <__stack+0x159>
 4ae:	99 35       	cpi	r25, 0x59	; 89
 4b0:	c0 f4       	brcc	.+48     	; 0x4e2 <__stack+0x83>
 4b2:	94 34       	cpi	r25, 0x44	; 68
 4b4:	09 f4       	brne	.+2      	; 0x4b8 <__stack+0x59>
 4b6:	4a c0       	rjmp	.+148    	; 0x54c <__stack+0xed>
 4b8:	95 34       	cpi	r25, 0x45	; 69
 4ba:	48 f4       	brcc	.+18     	; 0x4ce <__stack+0x6f>
 4bc:	92 34       	cpi	r25, 0x42	; 66
 4be:	09 f4       	brne	.+2      	; 0x4c2 <__stack+0x63>
 4c0:	7b c0       	rjmp	.+246    	; 0x5b8 <__stack+0x159>
 4c2:	93 34       	cpi	r25, 0x43	; 67
 4c4:	28 f5       	brcc	.+74     	; 0x510 <__stack+0xb1>
 4c6:	95 32       	cpi	r25, 0x25	; 37
 4c8:	09 f0       	breq	.+2      	; 0x4cc <__stack+0x6d>
 4ca:	8d c0       	rjmp	.+282    	; 0x5e6 <__stack+0x187>
 4cc:	89 c0       	rjmp	.+274    	; 0x5e0 <__stack+0x181>
 4ce:	93 35       	cpi	r25, 0x53	; 83
 4d0:	09 f4       	brne	.+2      	; 0x4d4 <__stack+0x75>
 4d2:	7c c0       	rjmp	.+248    	; 0x5cc <__stack+0x16d>
 4d4:	95 35       	cpi	r25, 0x55	; 85
 4d6:	09 f4       	brne	.+2      	; 0x4da <__stack+0x7b>
 4d8:	60 c0       	rjmp	.+192    	; 0x59a <__stack+0x13b>
 4da:	96 34       	cpi	r25, 0x46	; 70
 4dc:	09 f0       	breq	.+2      	; 0x4e0 <__stack+0x81>
 4de:	83 c0       	rjmp	.+262    	; 0x5e6 <__stack+0x187>
 4e0:	70 c0       	rjmp	.+224    	; 0x5c2 <__stack+0x163>
 4e2:	96 36       	cpi	r25, 0x66	; 102
 4e4:	09 f4       	brne	.+2      	; 0x4e8 <__stack+0x89>
 4e6:	6d c0       	rjmp	.+218    	; 0x5c2 <__stack+0x163>
 4e8:	97 36       	cpi	r25, 0x67	; 103
 4ea:	40 f4       	brcc	.+16     	; 0x4fc <__stack+0x9d>
 4ec:	93 36       	cpi	r25, 0x63	; 99
 4ee:	81 f0       	breq	.+32     	; 0x510 <__stack+0xb1>
 4f0:	94 36       	cpi	r25, 0x64	; 100
 4f2:	b1 f0       	breq	.+44     	; 0x520 <__stack+0xc1>
 4f4:	92 36       	cpi	r25, 0x62	; 98
 4f6:	09 f0       	breq	.+2      	; 0x4fa <__stack+0x9b>
 4f8:	76 c0       	rjmp	.+236    	; 0x5e6 <__stack+0x187>
 4fa:	5b c0       	rjmp	.+182    	; 0x5b2 <__stack+0x153>
 4fc:	95 37       	cpi	r25, 0x75	; 117
 4fe:	09 f4       	brne	.+2      	; 0x502 <__stack+0xa3>
 500:	43 c0       	rjmp	.+134    	; 0x588 <__stack+0x129>
 502:	98 37       	cpi	r25, 0x78	; 120
 504:	09 f4       	brne	.+2      	; 0x508 <__stack+0xa9>
 506:	55 c0       	rjmp	.+170    	; 0x5b2 <__stack+0x153>
 508:	93 37       	cpi	r25, 0x73	; 115
 50a:	09 f0       	breq	.+2      	; 0x50e <__stack+0xaf>
 50c:	6c c0       	rjmp	.+216    	; 0x5e6 <__stack+0x187>
 50e:	5e c0       	rjmp	.+188    	; 0x5cc <__stack+0x16d>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 510:	87 01       	movw	r16, r14
 512:	0e 5f       	subi	r16, 0xFE	; 254
 514:	1f 4f       	sbci	r17, 0xFF	; 255
				LCD_DisplayChar(ch);
 516:	f7 01       	movw	r30, r14
 518:	80 81       	ld	r24, Z
 51a:	0e 94 70 01 	call	0x2e0	; 0x2e0 <LCD_DisplayChar>
 51e:	5e c0       	rjmp	.+188    	; 0x5dc <__stack+0x17d>
				break;

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 520:	92 e0       	ldi	r25, 0x02	; 2
 522:	89 2e       	mov	r8, r25
 524:	91 2c       	mov	r9, r1
 526:	8e 0c       	add	r8, r14
 528:	9f 1c       	adc	r9, r15
 52a:	f7 01       	movw	r30, r14
 52c:	00 81       	ld	r16, Z
 52e:	11 81       	ldd	r17, Z+1	; 0x01
#if (Enable_LCD_DisplayDecimalNumber == 1)
				if(var_num_s16<0)
 530:	17 ff       	sbrs	r17, 7
 532:	06 c0       	rjmp	.+12     	; 0x540 <__stack+0xe1>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   var_num_s16 = -var_num_s16;
 534:	10 95       	com	r17
 536:	01 95       	neg	r16
 538:	1f 4f       	sbci	r17, 0xFF	; 255
				   LCD_DisplayChar('-');
 53a:	8d e2       	ldi	r24, 0x2D	; 45
 53c:	0e 94 70 01 	call	0x2e0	; 0x2e0 <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
 540:	b8 01       	movw	r22, r16
 542:	88 27       	eor	r24, r24
 544:	77 fd       	sbrc	r23, 7
 546:	80 95       	com	r24
 548:	98 2f       	mov	r25, r24
 54a:	19 c0       	rjmp	.+50     	; 0x57e <__stack+0x11f>
#endif
				break;
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 54c:	84 e0       	ldi	r24, 0x04	; 4
 54e:	88 2e       	mov	r8, r24
 550:	91 2c       	mov	r9, r1
 552:	8e 0c       	add	r8, r14
 554:	9f 1c       	adc	r9, r15
 556:	f7 01       	movw	r30, r14
 558:	e0 80       	ld	r14, Z
 55a:	f1 80       	ldd	r15, Z+1	; 0x01
 55c:	02 81       	ldd	r16, Z+2	; 0x02
 55e:	13 81       	ldd	r17, Z+3	; 0x03
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				if(var_num_s32<0)
 560:	17 ff       	sbrs	r17, 7
 562:	0b c0       	rjmp	.+22     	; 0x57a <__stack+0x11b>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   var_num_s32 = -var_num_s32;
 564:	10 95       	com	r17
 566:	00 95       	com	r16
 568:	f0 94       	com	r15
 56a:	e0 94       	com	r14
 56c:	e1 1c       	adc	r14, r1
 56e:	f1 1c       	adc	r15, r1
 570:	01 1d       	adc	r16, r1
 572:	11 1d       	adc	r17, r1
				   LCD_DisplayChar('-');
 574:	8d e2       	ldi	r24, 0x2D	; 45
 576:	0e 94 70 01 	call	0x2e0	; 0x2e0 <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
 57a:	c8 01       	movw	r24, r16
 57c:	b7 01       	movw	r22, r14
 57e:	4d 2d       	mov	r20, r13
 580:	0e 94 9b 01 	call	0x336	; 0x336 <LCD_DisplayDecimalNumber>
 584:	74 01       	movw	r14, r8
 586:	2f c0       	rjmp	.+94     	; 0x5e6 <__stack+0x187>
#endif				
				break;	

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 588:	87 01       	movw	r16, r14
 58a:	0e 5f       	subi	r16, 0xFE	; 254
 58c:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 58e:	f7 01       	movw	r30, r14
 590:	60 81       	ld	r22, Z
 592:	71 81       	ldd	r23, Z+1	; 0x01
 594:	80 e0       	ldi	r24, 0x00	; 0
 596:	90 e0       	ldi	r25, 0x00	; 0
 598:	08 c0       	rjmp	.+16     	; 0x5aa <__stack+0x14b>
#endif				
				break;
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 59a:	87 01       	movw	r16, r14
 59c:	0c 5f       	subi	r16, 0xFC	; 252
 59e:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
 5a0:	f7 01       	movw	r30, r14
 5a2:	60 81       	ld	r22, Z
 5a4:	71 81       	ldd	r23, Z+1	; 0x01
 5a6:	82 81       	ldd	r24, Z+2	; 0x02
 5a8:	93 81       	ldd	r25, Z+3	; 0x03
 5aa:	4d 2d       	mov	r20, r13
 5ac:	0e 94 9b 01 	call	0x336	; 0x336 <LCD_DisplayDecimalNumber>
 5b0:	15 c0       	rjmp	.+42     	; 0x5dc <__stack+0x17d>
#endif				
				break;

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
 5b2:	82 e0       	ldi	r24, 0x02	; 2
 5b4:	90 e0       	ldi	r25, 0x00	; 0
 5b6:	07 c0       	rjmp	.+14     	; 0x5c6 <__stack+0x167>
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
 5b8:	e4 e0       	ldi	r30, 0x04	; 4
 5ba:	f0 e0       	ldi	r31, 0x00	; 0
 5bc:	ee 0e       	add	r14, r30
 5be:	ff 1e       	adc	r15, r31
 5c0:	12 c0       	rjmp	.+36     	; 0x5e6 <__stack+0x187>
				break;


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
				var_floatNum_f32 = va_arg(argp, double);
 5c2:	84 e0       	ldi	r24, 0x04	; 4
 5c4:	90 e0       	ldi	r25, 0x00	; 0
 5c6:	e8 0e       	add	r14, r24
 5c8:	f9 1e       	adc	r15, r25
 5ca:	0d c0       	rjmp	.+26     	; 0x5e6 <__stack+0x187>
				break;


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
 5cc:	87 01       	movw	r16, r14
 5ce:	0e 5f       	subi	r16, 0xFE	; 254
 5d0:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_LCD_DisplayString == 1)
				LCD_DisplayString(str);
 5d2:	f7 01       	movw	r30, r14
 5d4:	80 81       	ld	r24, Z
 5d6:	91 81       	ldd	r25, Z+1	; 0x01
 5d8:	0e 94 0f 02 	call	0x41e	; 0x41e <LCD_DisplayString>
 5dc:	78 01       	movw	r14, r16
 5de:	03 c0       	rjmp	.+6      	; 0x5e6 <__stack+0x187>
#endif				
				break;

			case '%':
				LCD_DisplayChar('%');
 5e0:	85 e2       	ldi	r24, 0x25	; 37
			}
		}
		else
		{
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
 5e2:	0e 94 70 01 	call	0x2e0	; 0x2e0 <LCD_DisplayChar>
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 5e6:	08 94       	sec
 5e8:	a1 1c       	adc	r10, r1
 5ea:	b1 1c       	adc	r11, r1
 5ec:	f5 01       	movw	r30, r10
 5ee:	80 81       	ld	r24, Z
 5f0:	88 23       	and	r24, r24
 5f2:	09 f0       	breq	.+2      	; 0x5f6 <__stack+0x197>
 5f4:	3b cf       	rjmp	.-394    	; 0x46c <__stack+0xd>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
 5f6:	cf 91       	pop	r28
 5f8:	df 91       	pop	r29
 5fa:	1f 91       	pop	r17
 5fc:	0f 91       	pop	r16
 5fe:	ff 90       	pop	r15
 600:	ef 90       	pop	r14
 602:	df 90       	pop	r13
 604:	cf 90       	pop	r12
 606:	bf 90       	pop	r11
 608:	af 90       	pop	r10
 60a:	9f 90       	pop	r9
 60c:	8f 90       	pop	r8
 60e:	08 95       	ret

00000610 <__udivmodsi4>:
 610:	a1 e2       	ldi	r26, 0x21	; 33
 612:	1a 2e       	mov	r1, r26
 614:	aa 1b       	sub	r26, r26
 616:	bb 1b       	sub	r27, r27
 618:	fd 01       	movw	r30, r26
 61a:	0d c0       	rjmp	.+26     	; 0x636 <__udivmodsi4_ep>

0000061c <__udivmodsi4_loop>:
 61c:	aa 1f       	adc	r26, r26
 61e:	bb 1f       	adc	r27, r27
 620:	ee 1f       	adc	r30, r30
 622:	ff 1f       	adc	r31, r31
 624:	a2 17       	cp	r26, r18
 626:	b3 07       	cpc	r27, r19
 628:	e4 07       	cpc	r30, r20
 62a:	f5 07       	cpc	r31, r21
 62c:	20 f0       	brcs	.+8      	; 0x636 <__udivmodsi4_ep>
 62e:	a2 1b       	sub	r26, r18
 630:	b3 0b       	sbc	r27, r19
 632:	e4 0b       	sbc	r30, r20
 634:	f5 0b       	sbc	r31, r21

00000636 <__udivmodsi4_ep>:
 636:	66 1f       	adc	r22, r22
 638:	77 1f       	adc	r23, r23
 63a:	88 1f       	adc	r24, r24
 63c:	99 1f       	adc	r25, r25
 63e:	1a 94       	dec	r1
 640:	69 f7       	brne	.-38     	; 0x61c <__udivmodsi4_loop>
 642:	60 95       	com	r22
 644:	70 95       	com	r23
 646:	80 95       	com	r24
 648:	90 95       	com	r25
 64a:	9b 01       	movw	r18, r22
 64c:	ac 01       	movw	r20, r24
 64e:	bd 01       	movw	r22, r26
 650:	cf 01       	movw	r24, r30
 652:	08 95       	ret

00000654 <_exit>:
 654:	f8 94       	cli

00000656 <__stop_program>:
 656:	ff cf       	rjmp	.-2      	; 0x656 <__stop_program>
