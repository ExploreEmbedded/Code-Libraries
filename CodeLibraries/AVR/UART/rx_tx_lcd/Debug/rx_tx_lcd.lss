
rx_tx_lcd.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000684  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  00000684  00000718  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000005  00800066  00800066  0000071e  2**0
                  ALLOC
  3 .debug_aranges 00000080  00000000  00000000  0000071e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000001ad  00000000  00000000  0000079e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000b0d  00000000  00000000  0000094b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000464  00000000  00000000  00001458  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000a24  00000000  00000000  000018bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000170  00000000  00000000  000022e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000004d2  00000000  00000000  00002450  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000595  00000000  00000000  00002922  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000a8  00000000  00000000  00002eb7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e4 e8       	ldi	r30, 0x84	; 132
  68:	f6 e0       	ldi	r31, 0x06	; 6
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a6 36       	cpi	r26, 0x66	; 102
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a6 e6       	ldi	r26, 0x66	; 102
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ab 36       	cpi	r26, 0x6B	; 107
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 c4 02 	call	0x588	; 0x588 <main>
  8a:	0c 94 40 03 	jmp	0x680	; 0x680 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DELAY_sec>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  92:	40 e9       	ldi	r20, 0x90	; 144
  94:	51 e0       	ldi	r21, 0x01	; 1
  96:	09 c0       	rjmp	.+18     	; 0xaa <DELAY_sec+0x18>
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  98:	20 e1       	ldi	r18, 0x10	; 16
  9a:	37 e2       	ldi	r19, 0x27	; 39
  9c:	fa 01       	movw	r30, r20
  9e:	31 97       	sbiw	r30, 0x01	; 1
  a0:	f1 f7       	brne	.-4      	; 0x9e <DELAY_sec+0xc>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  a2:	21 50       	subi	r18, 0x01	; 1
  a4:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  a6:	d1 f7       	brne	.-12     	; 0x9c <DELAY_sec+0xa>
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
  a8:	01 97       	sbiw	r24, 0x01	; 1
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
  aa:	00 97       	sbiw	r24, 0x00	; 0
  ac:	a9 f7       	brne	.-22     	; 0x98 <DELAY_sec+0x6>
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
		}
  }
  ae:	08 95       	ret

000000b0 <lcd_BusyCheck>:
static void lcd_BusyCheck()
{
	uint8_t busyflag;
#ifdef LCD_RW       //Perform Busy check if LCD_RW pin is used

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
  b0:	a7 98       	cbi	0x14, 7	; 20
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
  b2:	a8 98       	cbi	0x15, 0	; 21
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
  b4:	a9 9a       	sbi	0x15, 1	; 21
		M_LcdSetBit(LCD_EN); 
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
  b6:	30 91 6a 00 	lds	r19, 0x006A
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
  ba:	95 e3       	ldi	r25, 0x35	; 53
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
	do
	{

		M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
  bc:	aa 98       	cbi	0x15, 2	; 21
  be:	89 2f       	mov	r24, r25
  c0:	8a 95       	dec	r24
  c2:	f1 f7       	brne	.-4      	; 0xc0 <lcd_BusyCheck+0x10>
		DELAY_us(10);	
		M_LcdSetBit(LCD_EN); 
  c4:	aa 9a       	sbi	0x15, 2	; 21
  c6:	89 2f       	mov	r24, r25
  c8:	8a 95       	dec	r24
  ca:	f1 f7       	brne	.-4      	; 0xc8 <lcd_BusyCheck+0x18>
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
  cc:	23 b3       	in	r18, 0x13	; 19


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
  ce:	34 30       	cpi	r19, 0x04	; 4
  d0:	41 f4       	brne	.+16     	; 0xe2 <lcd_BusyCheck+0x32>
		{
			/* Perform extra dummy read for 4-bit */ 	   	
			M_LcdClearBit(LCD_EN);
  d2:	aa 98       	cbi	0x15, 2	; 21
  d4:	89 2f       	mov	r24, r25
  d6:	8a 95       	dec	r24
  d8:	f1 f7       	brne	.-4      	; 0xd6 <lcd_BusyCheck+0x26>
			DELAY_us(10);
			M_LcdSetBit(LCD_EN); 
  da:	aa 9a       	sbi	0x15, 2	; 21
  dc:	89 2f       	mov	r24, r25
  de:	8a 95       	dec	r24
  e0:	f1 f7       	brne	.-4      	; 0xde <lcd_BusyCheck+0x2e>
			DELAY_us(10);
		}	
	}while(busyflag);
  e2:	27 fd       	sbrc	r18, 7
  e4:	eb cf       	rjmp	.-42     	; 0xbc <lcd_BusyCheck+0xc>

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
  e6:	a7 9a       	sbi	0x14, 7	; 20
#else
	/* Busy flag cannot be read as LCD_RW is not available hence Extra delay of 1ms is added 
	  to ensure the LCD completes previous operation and ready to receive new commands/data */
	DELAY_ms(1);  
#endif
}
  e8:	08 95       	ret

000000ea <lcd_SendNibble>:

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 *************************************************************************************************/
static void lcd_SendNibble(uint8_t var)
{
	util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
  ea:	98 2f       	mov	r25, r24
  ec:	84 ff       	sbrs	r24, 4
  ee:	02 c0       	rjmp	.+4      	; 0xf4 <lcd_SendNibble+0xa>
  f0:	ac 9a       	sbi	0x15, 4	; 21
  f2:	01 c0       	rjmp	.+2      	; 0xf6 <lcd_SendNibble+0xc>
  f4:	ac 98       	cbi	0x15, 4	; 21
  f6:	25 b3       	in	r18, 0x15	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
  f8:	95 ff       	sbrs	r25, 5
  fa:	02 c0       	rjmp	.+4      	; 0x100 <lcd_SendNibble+0x16>
  fc:	ad 9a       	sbi	0x15, 5	; 21
  fe:	01 c0       	rjmp	.+2      	; 0x102 <lcd_SendNibble+0x18>
 100:	ad 98       	cbi	0x15, 5	; 21
 102:	25 b3       	in	r18, 0x15	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
 104:	96 ff       	sbrs	r25, 6
 106:	02 c0       	rjmp	.+4      	; 0x10c <lcd_SendNibble+0x22>
 108:	ae 9a       	sbi	0x15, 6	; 21
 10a:	01 c0       	rjmp	.+2      	; 0x10e <lcd_SendNibble+0x24>
 10c:	ae 98       	cbi	0x15, 6	; 21
 10e:	95 b3       	in	r25, 0x15	; 21
	util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
 110:	87 ff       	sbrs	r24, 7
 112:	02 c0       	rjmp	.+4      	; 0x118 <lcd_SendNibble+0x2e>
 114:	af 9a       	sbi	0x15, 7	; 21
 116:	01 c0       	rjmp	.+2      	; 0x11a <lcd_SendNibble+0x30>
 118:	af 98       	cbi	0x15, 7	; 21
 11a:	85 b3       	in	r24, 0x15	; 21
 11c:	08 95       	ret

0000011e <lcd_SendCmdSignals>:

 * description : This functions generates the signals for sending the var_lcdCmd_u8 to LCD
 *************************************************************************************************/
static void lcd_SendCmdSignals()
{
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
 11e:	a8 98       	cbi	0x15, 0	; 21
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
 120:	a9 98       	cbi	0x15, 1	; 21
#endif
	M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
 122:	aa 9a       	sbi	0x15, 2	; 21
 124:	85 e3       	ldi	r24, 0x35	; 53
 126:	8a 95       	dec	r24
 128:	f1 f7       	brne	.-4      	; 0x126 <lcd_SendCmdSignals+0x8>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 12a:	aa 98       	cbi	0x15, 2	; 21
}
 12c:	08 95       	ret

0000012e <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.				
				The behaviour is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
{
 12e:	1f 93       	push	r17
 130:	18 2f       	mov	r17, r24
	lcd_BusyCheck();
 132:	0e 94 58 00 	call	0xb0	; 0xb0 <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 136:	80 91 6a 00 	lds	r24, 0x006A
 13a:	88 30       	cpi	r24, 0x08	; 8
 13c:	11 f4       	brne	.+4      	; 0x142 <LCD_CmdWrite+0x14>
	{

		M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
 13e:	15 bb       	out	0x15, r17	; 21
 140:	0c c0       	rjmp	.+24     	; 0x15a <LCD_CmdWrite+0x2c>
		lcd_SendCmdSignals();  // Signals for command write operation
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 142:	84 30       	cpi	r24, 0x04	; 4
 144:	61 f4       	brne	.+24     	; 0x15e <LCD_CmdWrite+0x30>
	{
		lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
 146:	81 2f       	mov	r24, r17
 148:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
		lcd_SendCmdSignals(); // Signals for command write operation
 14c:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>

		lcd_SendNibble(var_lcdCmd_u8 << 4);
 150:	81 2f       	mov	r24, r17
 152:	82 95       	swap	r24
 154:	80 7f       	andi	r24, 0xF0	; 240
 156:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
		lcd_SendCmdSignals();
 15a:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>
	}
}
 15e:	1f 91       	pop	r17
 160:	08 95       	ret

00000162 <LCD_GoToNextLine>:
 ***************************************************************************************************/
void  LCD_GoToNextLine()
{
	/*Increment the current line number.
	  In case it exceeds the limit, rool it back to first line */
	VAR_LcdTrackLineNum_U8++;
 162:	80 91 67 00 	lds	r24, 0x0067
 166:	8f 5f       	subi	r24, 0xFF	; 255
 168:	80 93 67 00 	sts	0x0067, r24
	VAR_LcdTrackCursorPos_U8 = 0x00;
 16c:	10 92 66 00 	sts	0x0066, r1
	if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
 170:	90 91 68 00 	lds	r25, 0x0068
 174:	98 17       	cp	r25, r24
 176:	18 f4       	brcc	.+6      	; 0x17e <LCD_GoToNextLine+0x1c>
		VAR_LcdTrackLineNum_U8 = 0x01;
 178:	81 e0       	ldi	r24, 0x01	; 1
 17a:	80 93 67 00 	sts	0x0067, r24
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
 17e:	e0 91 67 00 	lds	r30, 0x0067
 182:	f0 e0       	ldi	r31, 0x00	; 0
 184:	e0 5a       	subi	r30, 0xA0	; 160
 186:	ff 4f       	sbci	r31, 0xFF	; 255
 188:	80 81       	ld	r24, Z
 18a:	0e 94 97 00 	call	0x12e	; 0x12e <LCD_CmdWrite>
}
 18e:	08 95       	ret

00000190 <LCD_GoToLine>:
           mENUM_LcdLineTwo,
           mENUM_LcdLineThree,
           mENUM_LcdLineFour,
 ***************************************************************************************************/
void LCD_GoToLine(uint8_t var_lineNumber_u8)
{
 190:	e8 2f       	mov	r30, r24
	if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
 192:	80 91 68 00 	lds	r24, 0x0068
 196:	8e 17       	cp	r24, r30
 198:	50 f0       	brcs	.+20     	; 0x1ae <LCD_GoToLine+0x1e>
	{
		/* If the line number is within range then
	       Move the Cursor to beginning of the specified line */
		VAR_LcdTrackCursorPos_U8 = 0x00;
 19a:	10 92 66 00 	sts	0x0066, r1
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
 19e:	e0 93 67 00 	sts	0x0067, r30
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
 1a2:	f0 e0       	ldi	r31, 0x00	; 0
 1a4:	e0 5a       	subi	r30, 0xA0	; 160
 1a6:	ff 4f       	sbci	r31, 0xFF	; 255
 1a8:	80 81       	ld	r24, Z
 1aa:	0e 94 97 00 	call	0x12e	; 0x12e <LCD_CmdWrite>
 1ae:	08 95       	ret

000001b0 <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ***************************************************************************************************/
void LCD_Clear()
{
	LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
 1b0:	81 e0       	ldi	r24, 0x01	; 1
 1b2:	0e 94 97 00 	call	0x12e	; 0x12e <LCD_CmdWrite>
	LCD_GoToLine(mENUM_LcdLineOne);
 1b6:	81 e0       	ldi	r24, 0x01	; 1
 1b8:	0e 94 c8 00 	call	0x190	; 0x190 <LCD_GoToLine>
}
 1bc:	08 95       	ret

000001be <LCD_Init>:

 * description  :This function is used to initialize the lcd.
                 *It initializes the LCD for selected mode(4/8-bit) and Type(16x2/16x1 etc)
**************************************************************************************************/
void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
{
 1be:	0f 93       	push	r16
 1c0:	1f 93       	push	r17
 1c2:	58 2f       	mov	r21, r24


	M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
 1c4:	8f ef       	ldi	r24, 0xFF	; 255
 1c6:	84 bb       	out	0x14, r24	; 20
	M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
 1c8:	84 bb       	out	0x14, r24	; 20
	STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
 1ca:	50 93 6a 00 	sts	0x006A, r21
	STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
 1ce:	40 93 69 00 	sts	0x0069, r20
	STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
 1d2:	60 93 68 00 	sts	0x0068, r22
	if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
 1d6:	63 30       	cpi	r22, 0x03	; 3
 1d8:	40 f0       	brcs	.+16     	; 0x1ea <LCD_Init+0x2c>
	{
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
 1da:	84 2f       	mov	r24, r20
 1dc:	8f 70       	andi	r24, 0x0F	; 15
 1de:	80 57       	subi	r24, 0x70	; 112
 1e0:	80 93 63 00 	sts	0x0063, r24
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
 1e4:	80 5c       	subi	r24, 0xC0	; 192
 1e6:	80 93 64 00 	sts	0x0064, r24
 1ea:	88 ee       	ldi	r24, 0xE8	; 232
 1ec:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1ee:	20 e9       	ldi	r18, 0x90	; 144
 1f0:	31 e0       	ldi	r19, 0x01	; 1
 1f2:	f9 01       	movw	r30, r18
 1f4:	31 97       	sbiw	r30, 0x01	; 1
 1f6:	f1 f7       	brne	.-4      	; 0x1f4 <LCD_Init+0x36>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1f8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1fa:	d9 f7       	brne	.-10     	; 0x1f2 <LCD_Init+0x34>
	}

	DELAY_ms(100);

	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 1fc:	58 30       	cpi	r21, 0x08	; 8
 1fe:	11 f4       	brne	.+4      	; 0x204 <LCD_Init+0x46>
	{
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
 200:	88 e3       	ldi	r24, 0x38	; 56
 202:	2b c0       	rjmp	.+86     	; 0x25a <LCD_Init+0x9c>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 204:	54 30       	cpi	r21, 0x04	; 4
 206:	59 f5       	brne	.+86     	; 0x25e <LCD_Init+0xa0>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset()
{
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendNibble(0x30);
 208:	80 e3       	ldi	r24, 0x30	; 48
 20a:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
	lcd_SendCmdSignals();
 20e:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>
 212:	88 ee       	ldi	r24, 0xE8	; 232
 214:	93 e0       	ldi	r25, 0x03	; 3
 216:	20 e9       	ldi	r18, 0x90	; 144
 218:	31 e0       	ldi	r19, 0x01	; 1
 21a:	f9 01       	movw	r30, r18
 21c:	31 97       	sbiw	r30, 0x01	; 1
 21e:	f1 f7       	brne	.-4      	; 0x21c <LCD_Init+0x5e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 220:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 222:	d9 f7       	brne	.-10     	; 0x21a <LCD_Init+0x5c>
	DELAY_ms(100);
	lcd_SendNibble(0x30);
 224:	80 e3       	ldi	r24, 0x30	; 48
 226:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
	lcd_SendCmdSignals();
 22a:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>
 22e:	00 e2       	ldi	r16, 0x20	; 32
 230:	13 e0       	ldi	r17, 0x03	; 3
 232:	c8 01       	movw	r24, r16
 234:	01 97       	sbiw	r24, 0x01	; 1
 236:	f1 f7       	brne	.-4      	; 0x234 <LCD_Init+0x76>
	DELAY_us(200);
	lcd_SendNibble(0x30);
 238:	80 e3       	ldi	r24, 0x30	; 48
 23a:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
	lcd_SendCmdSignals();
 23e:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>
 242:	c8 01       	movw	r24, r16
 244:	01 97       	sbiw	r24, 0x01	; 1
 246:	f1 f7       	brne	.-4      	; 0x244 <LCD_Init+0x86>
	DELAY_us(200);
	lcd_SendNibble(0x20);
 248:	80 e2       	ldi	r24, 0x20	; 32
 24a:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
	lcd_SendCmdSignals();
 24e:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_SendCmdSignals>
 252:	c8 01       	movw	r24, r16
 254:	01 97       	sbiw	r24, 0x01	; 1
 256:	f1 f7       	brne	.-4      	; 0x254 <LCD_Init+0x96>
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
	{
		lcd_Reset();
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
 258:	88 e2       	ldi	r24, 0x28	; 40
 25a:	0e 94 97 00 	call	0x12e	; 0x12e <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);	 // Display ON cursor ON
 25e:	8e e0       	ldi	r24, 0x0E	; 14
 260:	0e 94 97 00 	call	0x12e	; 0x12e <LCD_CmdWrite>
	LCD_Clear();	                         // Clear the LCD and go to First line First Position
 264:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <LCD_Clear>
}
 268:	1f 91       	pop	r17
 26a:	0f 91       	pop	r16
 26c:	08 95       	ret

0000026e <lcd_SendDataSignals>:

 * description : This functions generates the signals for sending the Data to LCD
 *************************************************************************************************/
static void lcd_SendDataSignals()
{
	M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
 26e:	a8 9a       	sbi	0x15, 0	; 21
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
 270:	a9 98       	cbi	0x15, 1	; 21
#endif
	M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
 272:	aa 9a       	sbi	0x15, 2	; 21
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 274:	85 e3       	ldi	r24, 0x35	; 53
 276:	8a 95       	dec	r24
 278:	f1 f7       	brne	.-4      	; 0x276 <lcd_SendDataSignals+0x8>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
 27a:	aa 98       	cbi	0x15, 2	; 21
}
 27c:	08 95       	ret

0000027e <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
void LCD_DisplayChar(char var_lcdData_u8)
{
 27e:	1f 93       	push	r17
 280:	18 2f       	mov	r17, r24
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
 282:	90 91 66 00 	lds	r25, 0x0066
 286:	80 91 69 00 	lds	r24, 0x0069
 28a:	98 17       	cp	r25, r24
 28c:	10 f4       	brcc	.+4      	; 0x292 <LCD_DisplayChar+0x14>
 28e:	1a 30       	cpi	r17, 0x0A	; 10
 290:	21 f4       	brne	.+8      	; 0x29a <LCD_DisplayChar+0x1c>
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
 292:	0e 94 b1 00 	call	0x162	; 0x162 <LCD_GoToNextLine>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
 296:	1a 30       	cpi	r17, 0x0A	; 10
 298:	d9 f0       	breq	.+54     	; 0x2d0 <LCD_DisplayChar+0x52>

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void lcd_DataWrite( uint8_t dat)
{
	lcd_BusyCheck();
 29a:	0e 94 58 00 	call	0xb0	; 0xb0 <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
 29e:	80 91 6a 00 	lds	r24, 0x006A
 2a2:	88 30       	cpi	r24, 0x08	; 8
 2a4:	11 f4       	brne	.+4      	; 0x2aa <LCD_DisplayChar+0x2c>
	{
		M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
 2a6:	15 bb       	out	0x15, r17	; 21
 2a8:	0c c0       	rjmp	.+24     	; 0x2c2 <LCD_DisplayChar+0x44>
		lcd_SendDataSignals();  // Signals for data write operation
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
 2aa:	84 30       	cpi	r24, 0x04	; 4
 2ac:	61 f4       	brne	.+24     	; 0x2c6 <LCD_DisplayChar+0x48>
	{
		lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
 2ae:	81 2f       	mov	r24, r17
 2b0:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
		lcd_SendDataSignals();  // Signals for data write operation
 2b4:	0e 94 37 01 	call	0x26e	; 0x26e <lcd_SendDataSignals>

		lcd_SendNibble(dat << 4);
 2b8:	81 2f       	mov	r24, r17
 2ba:	82 95       	swap	r24
 2bc:	80 7f       	andi	r24, 0xF0	; 240
 2be:	0e 94 75 00 	call	0xea	; 0xea <lcd_SendNibble>
		lcd_SendDataSignals();
 2c2:	0e 94 37 01 	call	0x26e	; 0x26e <lcd_SendDataSignals>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
 2c6:	80 91 66 00 	lds	r24, 0x0066
 2ca:	8f 5f       	subi	r24, 0xFF	; 255
 2cc:	80 93 66 00 	sts	0x0066, r24
	}
}
 2d0:	1f 91       	pop	r17
 2d2:	08 95       	ret

000002d4 <LCD_DisplayDecimalNumber>:
				2.(12345,6) then 6-digits ie. 012345 will be displayed
				3.(12345,C_DisplayDefaultDigits_U8) then 12345 will be displayed.
 ***************************************************************************************************/
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
 2d4:	6f 92       	push	r6
 2d6:	7f 92       	push	r7
 2d8:	9f 92       	push	r9
 2da:	af 92       	push	r10
 2dc:	bf 92       	push	r11
 2de:	cf 92       	push	r12
 2e0:	df 92       	push	r13
 2e2:	ef 92       	push	r14
 2e4:	ff 92       	push	r15
 2e6:	0f 93       	push	r16
 2e8:	df 93       	push	r29
 2ea:	cf 93       	push	r28
 2ec:	cd b7       	in	r28, 0x3d	; 61
 2ee:	de b7       	in	r29, 0x3e	; 62
 2f0:	2a 97       	sbiw	r28, 0x0a	; 10
 2f2:	0f b6       	in	r0, 0x3f	; 63
 2f4:	f8 94       	cli
 2f6:	de bf       	out	0x3e, r29	; 62
 2f8:	0f be       	out	0x3f, r0	; 63
 2fa:	cd bf       	out	0x3d, r28	; 61
 2fc:	6b 01       	movw	r12, r22
 2fe:	7c 01       	movw	r14, r24
 300:	94 2e       	mov	r9, r20
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
 302:	61 15       	cp	r22, r1
 304:	71 05       	cpc	r23, r1
 306:	81 05       	cpc	r24, r1
 308:	91 05       	cpc	r25, r1
 30a:	31 f0       	breq	.+12     	; 0x318 <LCD_DisplayDecimalNumber+0x44>
 30c:	00 e0       	ldi	r16, 0x00	; 0
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
 30e:	3e 01       	movw	r6, r28
 310:	08 94       	sec
 312:	61 1c       	adc	r6, r1
 314:	71 1c       	adc	r7, r1
 316:	32 c0       	rjmp	.+100    	; 0x37c <LCD_DisplayDecimalNumber+0xa8>
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
 318:	fe 01       	movw	r30, r28
 31a:	31 96       	adiw	r30, 0x01	; 1
 31c:	00 e0       	ldi	r16, 0x00	; 0
 31e:	02 c0       	rjmp	.+4      	; 0x324 <LCD_DisplayDecimalNumber+0x50>
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
 320:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
 322:	0f 5f       	subi	r16, 0xFF	; 255
 324:	09 15       	cp	r16, r9
 326:	a8 f5       	brcc	.+106    	; 0x392 <LCD_DisplayDecimalNumber+0xbe>
 328:	0a 30       	cpi	r16, 0x0A	; 10
 32a:	d1 f7       	brne	.-12     	; 0x320 <LCD_DisplayDecimalNumber+0x4c>
 32c:	32 c0       	rjmp	.+100    	; 0x392 <LCD_DisplayDecimalNumber+0xbe>
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_DecNumber_u32!=0)
 32e:	c1 14       	cp	r12, r1
 330:	d1 04       	cpc	r13, r1
 332:	e1 04       	cpc	r14, r1
 334:	f1 04       	cpc	r15, r1
 336:	d1 f0       	breq	.+52     	; 0x36c <LCD_DisplayDecimalNumber+0x98>
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
 338:	53 01       	movw	r10, r6
 33a:	a0 0e       	add	r10, r16
 33c:	b1 1c       	adc	r11, r1
 33e:	c7 01       	movw	r24, r14
 340:	b6 01       	movw	r22, r12
 342:	2a e0       	ldi	r18, 0x0A	; 10
 344:	30 e0       	ldi	r19, 0x00	; 0
 346:	40 e0       	ldi	r20, 0x00	; 0
 348:	50 e0       	ldi	r21, 0x00	; 0
 34a:	0e 94 1e 03 	call	0x63c	; 0x63c <__udivmodsi4>
 34e:	f5 01       	movw	r30, r10
 350:	60 83       	st	Z, r22
				var_DecNumber_u32=var_DecNumber_u32/10;
 352:	c7 01       	movw	r24, r14
 354:	b6 01       	movw	r22, r12
 356:	2a e0       	ldi	r18, 0x0A	; 10
 358:	30 e0       	ldi	r19, 0x00	; 0
 35a:	40 e0       	ldi	r20, 0x00	; 0
 35c:	50 e0       	ldi	r21, 0x00	; 0
 35e:	0e 94 1e 03 	call	0x63c	; 0x63c <__udivmodsi4>
 362:	c9 01       	movw	r24, r18
 364:	da 01       	movw	r26, r20
 366:	6c 01       	movw	r12, r24
 368:	7d 01       	movw	r14, r26
 36a:	07 c0       	rjmp	.+14     	; 0x37a <LCD_DisplayDecimalNumber+0xa6>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
 36c:	fa e0       	ldi	r31, 0x0A	; 10
 36e:	f9 15       	cp	r31, r9
 370:	80 f0       	brcs	.+32     	; 0x392 <LCD_DisplayDecimalNumber+0xbe>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
 372:	f3 01       	movw	r30, r6
 374:	e0 0f       	add	r30, r16
 376:	f1 1d       	adc	r31, r1
 378:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
 37a:	0f 5f       	subi	r16, 0xFF	; 255
 37c:	09 15       	cp	r16, r9
 37e:	b8 f2       	brcs	.-82     	; 0x32e <LCD_DisplayDecimalNumber+0x5a>
 380:	08 c0       	rjmp	.+16     	; 0x392 <LCD_DisplayDecimalNumber+0xbe>


	while(i)
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
 382:	fe 01       	movw	r30, r28
 384:	e0 0f       	add	r30, r16
 386:	f1 1d       	adc	r31, r1
 388:	80 81       	ld	r24, Z
 38a:	80 5d       	subi	r24, 0xD0	; 208
 38c:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
		i--;
 390:	01 50       	subi	r16, 0x01	; 1
			}
		}
	}


	while(i)
 392:	00 23       	and	r16, r16
 394:	b1 f7       	brne	.-20     	; 0x382 <LCD_DisplayDecimalNumber+0xae>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
		i--;
	}
}
 396:	2a 96       	adiw	r28, 0x0a	; 10
 398:	0f b6       	in	r0, 0x3f	; 63
 39a:	f8 94       	cli
 39c:	de bf       	out	0x3e, r29	; 62
 39e:	0f be       	out	0x3f, r0	; 63
 3a0:	cd bf       	out	0x3d, r28	; 61
 3a2:	cf 91       	pop	r28
 3a4:	df 91       	pop	r29
 3a6:	0f 91       	pop	r16
 3a8:	ff 90       	pop	r15
 3aa:	ef 90       	pop	r14
 3ac:	df 90       	pop	r13
 3ae:	cf 90       	pop	r12
 3b0:	bf 90       	pop	r11
 3b2:	af 90       	pop	r10
 3b4:	9f 90       	pop	r9
 3b6:	7f 90       	pop	r7
 3b8:	6f 90       	pop	r6
 3ba:	08 95       	ret

000003bc <LCD_Printf>:
	     %12b: will display the 12-LSB of the number
		 %d: Will display the exact digits of the number
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
 3bc:	8f 92       	push	r8
 3be:	9f 92       	push	r9
 3c0:	af 92       	push	r10
 3c2:	bf 92       	push	r11
 3c4:	cf 92       	push	r12
 3c6:	df 92       	push	r13
 3c8:	ef 92       	push	r14
 3ca:	ff 92       	push	r15
 3cc:	0f 93       	push	r16
 3ce:	1f 93       	push	r17
 3d0:	df 93       	push	r29
 3d2:	cf 93       	push	r28
 3d4:	cd b7       	in	r28, 0x3d	; 61
 3d6:	de b7       	in	r29, 0x3e	; 62
 3d8:	31 e1       	ldi	r19, 0x11	; 17
 3da:	e3 2e       	mov	r14, r19
 3dc:	f1 2c       	mov	r15, r1
 3de:	ec 0e       	add	r14, r28
 3e0:	fd 1e       	adc	r15, r29
 3e2:	8f 85       	ldd	r24, Y+15	; 0x0f
 3e4:	98 89       	ldd	r25, Y+16	; 0x10
 3e6:	9c 01       	movw	r18, r24
 3e8:	59 01       	movw	r10, r18
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 3ea:	2a e0       	ldi	r18, 0x0A	; 10
 3ec:	c2 2e       	mov	r12, r18
 3ee:	ba c0       	rjmp	.+372    	; 0x564 <__stack+0x105>
	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
	{

		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
 3f0:	85 32       	cpi	r24, 0x25	; 37
 3f2:	09 f0       	breq	.+2      	; 0x3f6 <LCD_Printf+0x3a>
 3f4:	b2 c0       	rjmp	.+356    	; 0x55a <__stack+0xfb>
		{
		    ptr++;
 3f6:	08 94       	sec
 3f8:	a1 1c       	adc	r10, r1
 3fa:	b1 1c       	adc	r11, r1
		    ch = *ptr;
 3fc:	f5 01       	movw	r30, r10
 3fe:	90 81       	ld	r25, Z
		   if((ch>=0x30) && (ch<=0x39))
 400:	89 2f       	mov	r24, r25
 402:	80 53       	subi	r24, 0x30	; 48
 404:	8a 30       	cpi	r24, 0x0A	; 10
 406:	18 f0       	brcs	.+6      	; 0x40e <LCD_Printf+0x52>
 408:	dd 24       	eor	r13, r13
 40a:	da 94       	dec	r13
 40c:	0f c0       	rjmp	.+30     	; 0x42c <LCD_Printf+0x70>
 40e:	dd 24       	eor	r13, r13
 410:	09 c0       	rjmp	.+18     	; 0x424 <LCD_Printf+0x68>
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
 412:	dc 9c       	mul	r13, r12
 414:	d0 2c       	mov	r13, r0
 416:	11 24       	eor	r1, r1
 418:	d8 0e       	add	r13, r24
				   ptr++;
 41a:	08 94       	sec
 41c:	a1 1c       	adc	r10, r1
 41e:	b1 1c       	adc	r11, r1
				   ch = *ptr;
 420:	f5 01       	movw	r30, r10
 422:	90 81       	ld	r25, Z
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
 424:	89 2f       	mov	r24, r25
 426:	80 53       	subi	r24, 0x30	; 48
 428:	8a 30       	cpi	r24, 0x0A	; 10
 42a:	98 f3       	brcs	.-26     	; 0x412 <LCD_Printf+0x56>
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
			}				


			switch(ch)       /* Decode the type of the argument */
 42c:	98 35       	cpi	r25, 0x58	; 88
 42e:	09 f4       	brne	.+2      	; 0x432 <LCD_Printf+0x76>
 430:	86 c0       	rjmp	.+268    	; 0x53e <__stack+0xdf>
 432:	99 35       	cpi	r25, 0x59	; 89
 434:	c0 f4       	brcc	.+48     	; 0x466 <__stack+0x7>
 436:	94 34       	cpi	r25, 0x44	; 68
 438:	09 f4       	brne	.+2      	; 0x43c <LCD_Printf+0x80>
 43a:	4a c0       	rjmp	.+148    	; 0x4d0 <__stack+0x71>
 43c:	95 34       	cpi	r25, 0x45	; 69
 43e:	48 f4       	brcc	.+18     	; 0x452 <LCD_Printf+0x96>
 440:	92 34       	cpi	r25, 0x42	; 66
 442:	09 f4       	brne	.+2      	; 0x446 <LCD_Printf+0x8a>
 444:	7c c0       	rjmp	.+248    	; 0x53e <__stack+0xdf>
 446:	93 34       	cpi	r25, 0x43	; 67
 448:	28 f5       	brcc	.+74     	; 0x494 <__stack+0x35>
 44a:	95 32       	cpi	r25, 0x25	; 37
 44c:	09 f0       	breq	.+2      	; 0x450 <LCD_Printf+0x94>
 44e:	87 c0       	rjmp	.+270    	; 0x55e <__stack+0xff>
 450:	83 c0       	rjmp	.+262    	; 0x558 <__stack+0xf9>
 452:	93 35       	cpi	r25, 0x53	; 83
 454:	09 f4       	brne	.+2      	; 0x458 <LCD_Printf+0x9c>
 456:	7b c0       	rjmp	.+246    	; 0x54e <__stack+0xef>
 458:	95 35       	cpi	r25, 0x55	; 85
 45a:	09 f4       	brne	.+2      	; 0x45e <LCD_Printf+0xa2>
 45c:	60 c0       	rjmp	.+192    	; 0x51e <__stack+0xbf>
 45e:	96 34       	cpi	r25, 0x46	; 70
 460:	09 f0       	breq	.+2      	; 0x464 <__stack+0x5>
 462:	7d c0       	rjmp	.+250    	; 0x55e <__stack+0xff>
 464:	6f c0       	rjmp	.+222    	; 0x544 <__stack+0xe5>
 466:	96 36       	cpi	r25, 0x66	; 102
 468:	09 f4       	brne	.+2      	; 0x46c <__stack+0xd>
 46a:	6c c0       	rjmp	.+216    	; 0x544 <__stack+0xe5>
 46c:	97 36       	cpi	r25, 0x67	; 103
 46e:	40 f4       	brcc	.+16     	; 0x480 <__stack+0x21>
 470:	93 36       	cpi	r25, 0x63	; 99
 472:	81 f0       	breq	.+32     	; 0x494 <__stack+0x35>
 474:	94 36       	cpi	r25, 0x64	; 100
 476:	b1 f0       	breq	.+44     	; 0x4a4 <__stack+0x45>
 478:	92 36       	cpi	r25, 0x62	; 98
 47a:	09 f0       	breq	.+2      	; 0x47e <__stack+0x1f>
 47c:	70 c0       	rjmp	.+224    	; 0x55e <__stack+0xff>
 47e:	5c c0       	rjmp	.+184    	; 0x538 <__stack+0xd9>
 480:	95 37       	cpi	r25, 0x75	; 117
 482:	09 f4       	brne	.+2      	; 0x486 <__stack+0x27>
 484:	43 c0       	rjmp	.+134    	; 0x50c <__stack+0xad>
 486:	98 37       	cpi	r25, 0x78	; 120
 488:	09 f4       	brne	.+2      	; 0x48c <__stack+0x2d>
 48a:	56 c0       	rjmp	.+172    	; 0x538 <__stack+0xd9>
 48c:	93 37       	cpi	r25, 0x73	; 115
 48e:	09 f0       	breq	.+2      	; 0x492 <__stack+0x33>
 490:	66 c0       	rjmp	.+204    	; 0x55e <__stack+0xff>
 492:	5d c0       	rjmp	.+186    	; 0x54e <__stack+0xef>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
 494:	87 01       	movw	r16, r14
 496:	0e 5f       	subi	r16, 0xFE	; 254
 498:	1f 4f       	sbci	r17, 0xFF	; 255
				LCD_DisplayChar(ch);
 49a:	f7 01       	movw	r30, r14
 49c:	80 81       	ld	r24, Z
 49e:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
 4a2:	48 c0       	rjmp	.+144    	; 0x534 <__stack+0xd5>
				break;

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
 4a4:	92 e0       	ldi	r25, 0x02	; 2
 4a6:	89 2e       	mov	r8, r25
 4a8:	91 2c       	mov	r9, r1
 4aa:	8e 0c       	add	r8, r14
 4ac:	9f 1c       	adc	r9, r15
 4ae:	f7 01       	movw	r30, r14
 4b0:	00 81       	ld	r16, Z
 4b2:	11 81       	ldd	r17, Z+1	; 0x01
#if (Enable_LCD_DisplayDecimalNumber == 1)
				if(var_num_s16<0)
 4b4:	17 ff       	sbrs	r17, 7
 4b6:	06 c0       	rjmp	.+12     	; 0x4c4 <__stack+0x65>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   var_num_s16 = -var_num_s16;
 4b8:	10 95       	com	r17
 4ba:	01 95       	neg	r16
 4bc:	1f 4f       	sbci	r17, 0xFF	; 255
				   LCD_DisplayChar('-');
 4be:	8d e2       	ldi	r24, 0x2D	; 45
 4c0:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
 4c4:	b8 01       	movw	r22, r16
 4c6:	88 27       	eor	r24, r24
 4c8:	77 fd       	sbrc	r23, 7
 4ca:	80 95       	com	r24
 4cc:	98 2f       	mov	r25, r24
 4ce:	19 c0       	rjmp	.+50     	; 0x502 <__stack+0xa3>
#endif
				break;
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
 4d0:	84 e0       	ldi	r24, 0x04	; 4
 4d2:	88 2e       	mov	r8, r24
 4d4:	91 2c       	mov	r9, r1
 4d6:	8e 0c       	add	r8, r14
 4d8:	9f 1c       	adc	r9, r15
 4da:	f7 01       	movw	r30, r14
 4dc:	e0 80       	ld	r14, Z
 4de:	f1 80       	ldd	r15, Z+1	; 0x01
 4e0:	02 81       	ldd	r16, Z+2	; 0x02
 4e2:	13 81       	ldd	r17, Z+3	; 0x03
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				if(var_num_s32<0)
 4e4:	17 ff       	sbrs	r17, 7
 4e6:	0b c0       	rjmp	.+22     	; 0x4fe <__stack+0x9f>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   var_num_s32 = -var_num_s32;
 4e8:	10 95       	com	r17
 4ea:	00 95       	com	r16
 4ec:	f0 94       	com	r15
 4ee:	e0 94       	com	r14
 4f0:	e1 1c       	adc	r14, r1
 4f2:	f1 1c       	adc	r15, r1
 4f4:	01 1d       	adc	r16, r1
 4f6:	11 1d       	adc	r17, r1
				   LCD_DisplayChar('-');
 4f8:	8d e2       	ldi	r24, 0x2D	; 45
 4fa:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
 4fe:	c8 01       	movw	r24, r16
 500:	b7 01       	movw	r22, r14
 502:	4d 2d       	mov	r20, r13
 504:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <LCD_DisplayDecimalNumber>
 508:	74 01       	movw	r14, r8
 50a:	29 c0       	rjmp	.+82     	; 0x55e <__stack+0xff>
#endif				
				break;	

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
 50c:	87 01       	movw	r16, r14
 50e:	0e 5f       	subi	r16, 0xFE	; 254
 510:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
 512:	f7 01       	movw	r30, r14
 514:	60 81       	ld	r22, Z
 516:	71 81       	ldd	r23, Z+1	; 0x01
 518:	80 e0       	ldi	r24, 0x00	; 0
 51a:	90 e0       	ldi	r25, 0x00	; 0
 51c:	08 c0       	rjmp	.+16     	; 0x52e <__stack+0xcf>
#endif				
				break;
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
 51e:	87 01       	movw	r16, r14
 520:	0c 5f       	subi	r16, 0xFC	; 252
 522:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
 524:	f7 01       	movw	r30, r14
 526:	60 81       	ld	r22, Z
 528:	71 81       	ldd	r23, Z+1	; 0x01
 52a:	82 81       	ldd	r24, Z+2	; 0x02
 52c:	93 81       	ldd	r25, Z+3	; 0x03
 52e:	4d 2d       	mov	r20, r13
 530:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <LCD_DisplayDecimalNumber>
 534:	78 01       	movw	r14, r16
 536:	13 c0       	rjmp	.+38     	; 0x55e <__stack+0xff>
#endif				
				break;

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
 538:	82 e0       	ldi	r24, 0x02	; 2
 53a:	90 e0       	ldi	r25, 0x00	; 0
 53c:	05 c0       	rjmp	.+10     	; 0x548 <__stack+0xe9>
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
 53e:	e4 e0       	ldi	r30, 0x04	; 4
 540:	f0 e0       	ldi	r31, 0x00	; 0
 542:	07 c0       	rjmp	.+14     	; 0x552 <__stack+0xf3>
				break;


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
				var_floatNum_f32 = va_arg(argp, double);
 544:	84 e0       	ldi	r24, 0x04	; 4
 546:	90 e0       	ldi	r25, 0x00	; 0
 548:	e8 0e       	add	r14, r24
 54a:	f9 1e       	adc	r15, r25
 54c:	08 c0       	rjmp	.+16     	; 0x55e <__stack+0xff>
				break;


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
 54e:	e2 e0       	ldi	r30, 0x02	; 2
 550:	f0 e0       	ldi	r31, 0x00	; 0
 552:	ee 0e       	add	r14, r30
 554:	ff 1e       	adc	r15, r31
 556:	03 c0       	rjmp	.+6      	; 0x55e <__stack+0xff>
				LCD_DisplayString(str);
#endif				
				break;

			case '%':
				LCD_DisplayChar('%');
 558:	85 e2       	ldi	r24, 0x25	; 37
			}
		}
		else
		{
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
 55a:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
 55e:	08 94       	sec
 560:	a1 1c       	adc	r10, r1
 562:	b1 1c       	adc	r11, r1
 564:	f5 01       	movw	r30, r10
 566:	80 81       	ld	r24, Z
 568:	88 23       	and	r24, r24
 56a:	09 f0       	breq	.+2      	; 0x56e <__stack+0x10f>
 56c:	41 cf       	rjmp	.-382    	; 0x3f0 <LCD_Printf+0x34>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
 56e:	cf 91       	pop	r28
 570:	df 91       	pop	r29
 572:	1f 91       	pop	r17
 574:	0f 91       	pop	r16
 576:	ff 90       	pop	r15
 578:	ef 90       	pop	r14
 57a:	df 90       	pop	r13
 57c:	cf 90       	pop	r12
 57e:	bf 90       	pop	r11
 580:	af 90       	pop	r10
 582:	9f 90       	pop	r9
 584:	8f 90       	pop	r8
 586:	08 95       	ret

00000588 <main>:
#include "lcd.h"	//User defined LCD library which contains the lcd routines


/* start the main program */
void main() 
{
 588:	1f 93       	push	r17
   	 char ch='m';

  /* Initialize the UART before Transmitting/Receiving any data */
    UART_Init(9600);
 58a:	60 e8       	ldi	r22, 0x80	; 128
 58c:	75 e2       	ldi	r23, 0x25	; 37
 58e:	80 e0       	ldi	r24, 0x00	; 0
 590:	90 e0       	ldi	r25, 0x00	; 0
 592:	0e 94 04 03 	call	0x608	; 0x608 <UART_Init>

  /* Initialize the lcd before displaying any thing on the lcd */
    LCD_Init(4,2,16);
 596:	84 e0       	ldi	r24, 0x04	; 4
 598:	62 e0       	ldi	r22, 0x02	; 2
 59a:	40 e1       	ldi	r20, 0x10	; 16
 59c:	0e 94 df 00 	call	0x1be	; 0x1be <LCD_Init>

   while(1)
    {
	    /*Receive and Transmit a char indefinitely at 9600 baud rate */
	    ch=UART_RxChar(); // Receive a char and store it in "ch"
 5a0:	0e 94 0c 03 	call	0x618	; 0x618 <UART_RxChar>
 5a4:	18 2f       	mov	r17, r24
        
         UART_TxChar(ch);  //Transmit the received char
 5a6:	0e 94 10 03 	call	0x620	; 0x620 <UART_TxChar>

		 LCD_DisplayChar(ch); //Display the received char on LCD
 5aa:	81 2f       	mov	r24, r17
 5ac:	0e 94 3f 01 	call	0x27e	; 0x27e <LCD_DisplayChar>
 5b0:	f7 cf       	rjmp	.-18     	; 0x5a0 <main+0x18>

000005b2 <UART_SetBaudRate>:
                 the default baudrate of 9600 is set.

		    Refer uart.h file for Supported range of baud rates.
***************************************************************************************************/
void UART_SetBaudRate(uint32_t var_baudRate_u32)
{
 5b2:	9b 01       	movw	r18, r22
 5b4:	ac 01       	movw	r20, r24
	uint16_t RegValue;

	if((var_baudRate_u32 >= C_MinBaudRate_U32) && (var_baudRate_u32<=C_MaxBaudRate_U32))
 5b6:	dc 01       	movw	r26, r24
 5b8:	cb 01       	movw	r24, r22
 5ba:	80 56       	subi	r24, 0x60	; 96
 5bc:	99 40       	sbci	r25, 0x09	; 9
 5be:	a0 40       	sbci	r26, 0x00	; 0
 5c0:	b0 40       	sbci	r27, 0x00	; 0
 5c2:	81 5a       	subi	r24, 0xA1	; 161
 5c4:	98 4b       	sbci	r25, 0xB8	; 184
 5c6:	a1 40       	sbci	r26, 0x01	; 1
 5c8:	b0 40       	sbci	r27, 0x00	; 0
 5ca:	18 f0       	brcs	.+6      	; 0x5d2 <UART_SetBaudRate+0x20>
 5cc:	27 e6       	ldi	r18, 0x67	; 103
 5ce:	30 e0       	ldi	r19, 0x00	; 0
 5d0:	18 c0       	rjmp	.+48     	; 0x602 <UART_SetBaudRate+0x50>
	{
		/* Check if the requested baudate is within range,
	     If yes then calculate the value to be loaded into baud rate generator. */
		RegValue = M_GetBaudRateGeneratorValue(var_baudRate_u32);
 5d2:	60 e8       	ldi	r22, 0x80	; 128
 5d4:	74 e8       	ldi	r23, 0x84	; 132
 5d6:	8e e1       	ldi	r24, 0x1E	; 30
 5d8:	90 e0       	ldi	r25, 0x00	; 0
 5da:	62 1b       	sub	r22, r18
 5dc:	73 0b       	sbc	r23, r19
 5de:	84 0b       	sbc	r24, r20
 5e0:	95 0b       	sbc	r25, r21
 5e2:	f3 e0       	ldi	r31, 0x03	; 3
 5e4:	66 0f       	add	r22, r22
 5e6:	77 1f       	adc	r23, r23
 5e8:	88 1f       	adc	r24, r24
 5ea:	99 1f       	adc	r25, r25
 5ec:	fa 95       	dec	r31
 5ee:	d1 f7       	brne	.-12     	; 0x5e4 <UART_SetBaudRate+0x32>
 5f0:	e4 e0       	ldi	r30, 0x04	; 4
 5f2:	22 0f       	add	r18, r18
 5f4:	33 1f       	adc	r19, r19
 5f6:	44 1f       	adc	r20, r20
 5f8:	55 1f       	adc	r21, r21
 5fa:	ea 95       	dec	r30
 5fc:	d1 f7       	brne	.-12     	; 0x5f2 <UART_SetBaudRate+0x40>
 5fe:	0e 94 1e 03 	call	0x63c	; 0x63c <__udivmodsi4>
	{
		/*	 Invalid baudrate requested, hence set it to default baudrate of 9600 */
		RegValue = M_GetBaudRateGeneratorValue(9600);
	}

	UBRRL = util_ExtractByte0to8(RegValue);
 602:	29 b9       	out	0x09, r18	; 9
	UBRRH = util_ExtractByte8to16(RegValue);
 604:	30 bd       	out	0x20, r19	; 32
}
 606:	08 95       	ret

00000608 <UART_Init>:

		    Refer uart.h file for Supported(range) baud rates.		
***************************************************************************************************/
void UART_Init(uint32_t var_baudRate_u32)
{
	UCSRB= (1<<RXEN) | (1<<TXEN);                  // Enable Receiver and Transmitter
 608:	28 e1       	ldi	r18, 0x18	; 24
 60a:	2a b9       	out	0x0a, r18	; 10
	UCSRC= (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);   // Asynchronous mode 8-bit data and 1-stop bit
 60c:	26 e8       	ldi	r18, 0x86	; 134
 60e:	20 bd       	out	0x20, r18	; 32
	UCSRA= 0x00;                                   // Clear the UASRT status register
 610:	1b b8       	out	0x0b, r1	; 11
	UART_SetBaudRate(var_baudRate_u32);
 612:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <UART_SetBaudRate>
}
 616:	08 95       	ret

00000618 <UART_RxChar>:
 * description :This function is used to receive a char from UART module.
                It waits till a char is received and returns it after reception.
***************************************************************************************************/
char UART_RxChar()
{
	while(util_IsBitCleared(UCSRA,RXC));  // Wait till the data is received
 618:	5f 9b       	sbis	0x0b, 7	; 11
 61a:	fe cf       	rjmp	.-4      	; 0x618 <UART_RxChar>
	return(UDR);                          // return the received char
 61c:	8c b1       	in	r24, 0x0c	; 12
}
 61e:	08 95       	ret

00000620 <UART_TxChar>:

 * description  :This function is used to transmit a char through UART module.
***************************************************************************************************/
void UART_TxChar(char var_uartData_u8)
{
	while(util_IsBitCleared(UCSRA,UDRE)); // Wait till Transmitter(UDR) register becomes Empty
 620:	5d 9b       	sbis	0x0b, 5	; 11
 622:	fe cf       	rjmp	.-4      	; 0x620 <UART_TxChar>
	UDR =var_uartData_u8;                              // Load the data to be transmitted
 624:	8c b9       	out	0x0c, r24	; 12
}
 626:	08 95       	ret

00000628 <UART_TxString>:
               1.The ptr_stringPointer_u8 points to the first char of the string
                    and traverses till the end(NULL CHAR) and transmits a char each time
***************************************************************************************************/
#if (Enable_UART_TxString==1)
void UART_TxString(char *ptr_stringPointer_u8)
{
 628:	fc 01       	movw	r30, r24
 62a:	04 c0       	rjmp	.+8      	; 0x634 <UART_TxString+0xc>

 * description  :This function is used to transmit a char through UART module.
***************************************************************************************************/
void UART_TxChar(char var_uartData_u8)
{
	while(util_IsBitCleared(UCSRA,UDRE)); // Wait till Transmitter(UDR) register becomes Empty
 62c:	5d 9b       	sbis	0x0b, 5	; 11
 62e:	fe cf       	rjmp	.-4      	; 0x62c <UART_TxString+0x4>
***************************************************************************************************/
#if (Enable_UART_TxString==1)
void UART_TxString(char *ptr_stringPointer_u8)
{
	while(*ptr_stringPointer_u8)
		UART_TxChar(*ptr_stringPointer_u8++);// Loop through the string and transmit char by char
 630:	31 96       	adiw	r30, 0x01	; 1
 * description  :This function is used to transmit a char through UART module.
***************************************************************************************************/
void UART_TxChar(char var_uartData_u8)
{
	while(util_IsBitCleared(UCSRA,UDRE)); // Wait till Transmitter(UDR) register becomes Empty
	UDR =var_uartData_u8;                              // Load the data to be transmitted
 632:	8c b9       	out	0x0c, r24	; 12
                    and traverses till the end(NULL CHAR) and transmits a char each time
***************************************************************************************************/
#if (Enable_UART_TxString==1)
void UART_TxString(char *ptr_stringPointer_u8)
{
	while(*ptr_stringPointer_u8)
 634:	80 81       	ld	r24, Z
 636:	88 23       	and	r24, r24
 638:	c9 f7       	brne	.-14     	; 0x62c <UART_TxString+0x4>
		UART_TxChar(*ptr_stringPointer_u8++);// Loop through the string and transmit char by char
}
 63a:	08 95       	ret

0000063c <__udivmodsi4>:
 63c:	a1 e2       	ldi	r26, 0x21	; 33
 63e:	1a 2e       	mov	r1, r26
 640:	aa 1b       	sub	r26, r26
 642:	bb 1b       	sub	r27, r27
 644:	fd 01       	movw	r30, r26
 646:	0d c0       	rjmp	.+26     	; 0x662 <__udivmodsi4_ep>

00000648 <__udivmodsi4_loop>:
 648:	aa 1f       	adc	r26, r26
 64a:	bb 1f       	adc	r27, r27
 64c:	ee 1f       	adc	r30, r30
 64e:	ff 1f       	adc	r31, r31
 650:	a2 17       	cp	r26, r18
 652:	b3 07       	cpc	r27, r19
 654:	e4 07       	cpc	r30, r20
 656:	f5 07       	cpc	r31, r21
 658:	20 f0       	brcs	.+8      	; 0x662 <__udivmodsi4_ep>
 65a:	a2 1b       	sub	r26, r18
 65c:	b3 0b       	sbc	r27, r19
 65e:	e4 0b       	sbc	r30, r20
 660:	f5 0b       	sbc	r31, r21

00000662 <__udivmodsi4_ep>:
 662:	66 1f       	adc	r22, r22
 664:	77 1f       	adc	r23, r23
 666:	88 1f       	adc	r24, r24
 668:	99 1f       	adc	r25, r25
 66a:	1a 94       	dec	r1
 66c:	69 f7       	brne	.-38     	; 0x648 <__udivmodsi4_loop>
 66e:	60 95       	com	r22
 670:	70 95       	com	r23
 672:	80 95       	com	r24
 674:	90 95       	com	r25
 676:	9b 01       	movw	r18, r22
 678:	ac 01       	movw	r20, r24
 67a:	bd 01       	movw	r22, r26
 67c:	cf 01       	movw	r24, r30
 67e:	08 95       	ret

00000680 <_exit>:
 680:	f8 94       	cli

00000682 <__stop_program>:
 682:	ff cf       	rjmp	.-2      	; 0x682 <__stop_program>
